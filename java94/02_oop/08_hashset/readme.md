# Коллекции HashSet и HashMap

Лекция про ассоциативные массивы (Мапы) и множества - на примере хэшируемых структур данных.

## Нативная реализация ассоциативного массива

Представим себе простой список, списки умеют хранить данные под номерами (все ячейки пронумерованы). `list.add("smth");` всегда добавляет новую ячейку в конец. Также мы можем доставать элемент по индексу.  
Допустим, мы хотим наклеить другие ярлыки на ячейки. Например, у нас будет какой нибудь класс, который хранит инфу о пользователе, а пользователь индентифицируется по имени. То есть мы бы хотели какую-то коллекцию, чтобы мы указывали в сет не номер ячейки, а имя `map.set("Petya", new UserInfo());`, `map.get("Petya");`. То есть мы хотим такую вещь, где нет номеров ячеек, а есть по сути метка в виде другого объекта (тут - в виде строки). В джаве уже есть интерфейс для подобного вида коллекций (если быть точным - джава не считает это коллекцией), только там вместо set - put.
```java
public class Main {

    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("Petya");
        list.add("Olya");
        list.add("Tanya");

        String name = list.get(1);
        list.set(1, "Kolya");

        MyMap<String, UserInfo> map = new MyMap<>();
        map.put("Petya", new UserInfo(8));
        map.put("Olya", new UserInfo(15));
        UserInfo info = map.get("Olya");
    }
}
```
`"Petya"` мы уже не можем называть индексом, посколько индекс несет под собой числовой смысл. Такие ячейки мы называем ключами. Так как в целом это все похоже на массив, то мы можем встретить такой термин как ассоциативный массив - мы берем и ставим ассоциацию между значением и ключом. 

Попробуем сами создать такой тип данных. Попробуем сделать так чтобы у нас в качестве ключа была не обязательно строка - поэтому проставим 2 дженерик параметра `public class MyMap<K, V> `.
```java
public class MyMap<K, V> {
    public void put(K key, V value) {
    }

    public V get(K key) {
    }
}
```
Мы можем реализовать в виде одного большого списка, а каждым элементом будут пары ключ-значение. Создадим класс, который будет хранить пары ключ-значение. Он тоже будет параметризирован - поскольку будет хранить ключ-значение, а типами может быть что угодно. Также создадим геттеры и сеттеры (для ключа только геттер)
```java
public class MyMapPair<K, V> {
    protected K key;
    protected V value;

    public MyMapPair(K key, V value) {
        this.key = key;
        this.value = value;
    }

    public K getKey() {
        return key;
    }

    public V getValue() {
        return value;
    }

    public void setValue(V value) {
        this.value = value;
    }
}
```
Создав класс MyMapPair мы можем создать поле, в котором будет список из всех добавленных ключ-значение. Это будет ArrayList и изначально он будет полностью пустой. Когда нас будут просить добавить новое значение, мы должны сделать 2 вещи - проверить, есть ли уже такой ключ в нашем списке. Если есть, то мы просто поменяем ему значение на новое. Если же нет - то создадим новую пару ключ-значение из тех значений, которые нам передали в параметр, и вставим в конец списка.
```java
import java.util.ArrayList;
import java.util.List;

public class MyMap<K, V> {
    protected List<MyMapPair<K, V>> pairs = new ArrayList<>();

    public void put(K key, V value) {
        for (MyMapPair<K, V> kv : pairs) {
            if (kv.getKey().equals(key)) {
                kv.setValue(value);
                return;
            }
        }
        // если мы не вышли через return - значит такого ключа нет и нам нужно создать новую пару
        MyMapPair<K, V> newKv = new MyMapPair<>(key, value);
        pairs.add(newKv);
    }

    public V get(K key) {
        for (MyMapPair<K, V> kv : pairs) {
            if (kv.getKey().equals(key)) {
                return kv.getValue();
            }
        }
        // если мы пробежались по всему списку пар и не нашли значения - значит, возвращаем налл
        return null;
    }
}
```
Убедимся в работоспособности. Для этого создадим класс UserInfo
```java
public class UserInfo {
    protected int age;

    public UserInfo(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        // так мы будет понимать, что у нас мапа действительно работает
        return "" + age;
    }
}
```
А теперь проверим в мэин
```java
import java.util.ArrayList;
import java.util.List;

public class Main {

    public static void main(String[] args) {
        MyMap<String, UserInfo> map = new MyMap<>();
        map.put("Petya", new UserInfo(8));
        map.put("Olya", new UserInfo(15));
        UserInfo info = map.get("Olya");
        System.out.println(info);
    }
}
```
Однако производительность оставляет желать лучшего - ведь при вставке каждого ключа нам приходится пробегать по всем уже вставленным парам ключ-значение. Мы бы хотели что нибудь побыстрее - например, при работе с массивами при обращении к ячейке мы вообще не зависим от величины этого массива. Тут же зависим - и чем величина больше, тем дольше перебирается цикл.

## Хэширование и HashMap

Реализация HashMap основана на идее хэширования. В джаве есть стандартный интерфейс Map. Он объединяет в себе все виды ассоциативный массивов. Это дженерик интерфейс, он принимает у себя 2 параметра, тип ключа и тип значения. `Map<String, Integer> map = new HashMap<>();` - конкретно под наш пример, будем сохранять каждому пользователю возраст. Класс выберем HashMap
```java
import java.util.HashMap;
import java.util.Map;

public class Main {

    public static void main(String[] args) {
        Map<String, Integer> map = new HashMap<>();
        map.put("Petya", 8);
        map.put("Tanya", 15);
        //int age = map.get("Tanya");
    }
}
```
Посмотрим на теоретические основы HashMap. HashMap хранит всю информацию в списке пар ключ-значение. Однако она использует не один список, а множество списков. Суть подхода в том, что HashMap глядя на ключ может сразу определить, в какой списке он потенциально может быть. Причем HashMap уверен что этот ключ именно в этом списке (если он вообще есть), а в других его нет, поэтому остальное перебирать не надо.

Рассмотрим поближе хэширование. У каждого объекта в джаве есть специальный метод, он называется хэш код `"hello".hashCode();`. Этот метод всегда возвращает число. По смыслу оно означает вот что - задачей каждого типа, который предположительно может использоваться при хэшировании, это правильно реализовать функцию hashCode (на одинаковых объектах hashCode должен возвращать одно и то же число, на разных - может возвращать одно и то же число, а может и разные, но лучше бы разные). Аналог из реального мира - рост. У абсолютно одинаковых людей рост совпадает, у разных людей рост может совпадать, а может и нет. HashMap требует, чтобы у объекта ключа можно было вычислить хэш код. Причем ключ должен не меняться, пока он там находится, потому что HashMap смотрит на хэш код ключа, чтобы определить, в каком же списке ей надо будет искать эту пару ключ-значение. Мы можем использовать `String` без каких либо ограничений, потому что String - это встроенных джавовский тип и у него все хорошо с хэш кодом. Если же мы будем использовать собственный тип данных, то нам нужно будет переопределить `hashCode()`.

Как же нам придумать алгоритм, который бы возвращал одинаковые значения на одинаковых объектах и разные - на разных. Это означает, что если оба объекта на `name.equals(o.name)` возвращают True, то эти объекты одинаковы. Если у нас есть несколько полей, которые участвуют в понятии равенства, то нам нужно совпасть по им обоим, надо возвращать хэш код и по имени, и по фамилии `Objects.hash(name, surname)`, комбинирование через сложение - это плохая идея, метод hash позмоляют считать хэш от нескольких объектов.
```java
import java.util.Objects;

public class UserInfo {
    protected String name;
    protected String surname;
    protected int age;

    public UserInfo(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, surname);
    }

    @Override
    public boolean equals(Object obj) {
        // у нас тут Object, но будем считать что нам всегда приходит UserInfo
        UserInfo o = (UserInfo) obj;
        return name.equals(o.name) && surname.equals(o.surname);
    }
}
```
Помимо пут и гет у мап есть огромное колоичество методов. Например, можем посмотреть, содержит ли мапа какой то ключ или попросить мапу удалить какой то ключ.  
Посмотрим, как мы можем итерироваться чтобы перебрать все значения в мапе. ВЕдь не всегда нам важно только получение информации по фиксированному ключу, иногда хочется пройтись целиком по всей мапе. keySet вернет нам все ключи.
```java
import java.util.HashMap;
import java.util.Map;

public class Main {

    public static void main(String[] args) {
        Map<String, Integer> map = new HashMap<>();
        map.put("Petya", 8);
        map.put("Tanya", 15);
        //int age = map.get("Tanya");

        for (String key : map.keySet()) {
            int value = map.get(key);
            System.out.println(key + " - " + value);
        }

        // другой способ итерирования - мапа дает нам коллекцию из пар ключ-значение
        // Map.Entry - встроенный интерфейс, где мы можем указать ключ и значение
        // Map не является технически коллекцией для пар ключ-значение. Да, они там хранятся, но
        // Джава не говорит, что мапа является именно коллекцией, мы не можем по ней пройтись
        // через цикл foreach. Мы должны у нее спросить - дай ка множество мне из коллекций пар
        // ключ-значение
        for (Map.Entry<String, Integer> kv : map.entrySet()) {
            System.out.println(kv.getKey() + " = " + kv.getValue());
        }
    }
}
```

## Множества и HashSet

Познакомимся с таким важным семейством коллекций, как множества и рассмотрим их работу на примере HashSet.

Все множества в джаве объединяет интерфейс Set. Здесь мы можем указывать в качестве дженерик параметра тот класс элементов, который мы хотим там хранить. Создадим сет из стрингов `Set<String> set = new HashSet<>();`. Что такое множество по смыслу: если списки - это набор пронумерованных элементов, то множество - это просто набор элементов, где порядок не важен. Также эти коллекции сами сразу следят чтобы у нас не было дубликатов там (мы не сможем добавить 2 одинаковых объекта). Также множество не гарантирует нам какой нибудь порядок.
```java
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class Main {

    public static void main(String[] args) {
        Set<String> set = new HashSet<>();
        set.add("Petya");
        set.add("Olya");
        set.add("Petya");
        System.out.println(set);  // второй раз Petya не добавится!
        System.out.println(set.contains("Olya"));
    }
}
```
Как работает contains в списках: мы просто идем по всему списку, перебираем все ячейки и сравниваем. Проблема в том, что чем больше список, тем медленней все работает. Множества же устроены хитрее и работают гораздо быстрее, независимо от величины множества. HashSet внутри себя устроен на HashMap. Мы храним наши элементы HashSet в качестве ключей в HashMap, в качестве значений же нам все равно что хранить, будем хранить один и тот же объект, он будет бессмысленный. Так как мапа у нас очень быстро работает с ключами - у нас автоматичяески получается очень быстрая работа HashSet-а. Ну и ограничения те же - в качестве элементов HashSet мы можем использовать только те элементы, у которых корректно реализован `hashCode()`. Также нам нельзя менять элементы, которые мы добавили в множество.