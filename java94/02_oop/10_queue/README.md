# Коллекции Queue

## Очереди и Priority Queue

Все очереди объединяются одним интерфейсом - Queue. Он принимает в качестве дженерик параметра 1 тип, а конкретно - тип его элементов. Очередь представляет собой коллекцию, в которую мы можем добавлять элементы и изымать элементы из нее. В сама простом виде в очередь обычно встают в конец, а выходят из начала. Сделаем очередь из стрингов, сперва сделаем как `LinkedList`
```java
import java.util.LinkedList;

public class Main {

    public static void main(String[] args) {
        Queue<String> queue = new LinkedList<>();
        queue.add("Petya");
        queue.add("Olya");
        queue.add("Tanya");
    }
}
```
Однако само понятие очередь не подразумевают собой что она может быть безгранична. Поэтому бывают такие реализации очередей, которые предполагают ограниченное количество элементов. Если мы будем добавлять в очередь через метод `add`, то иногда очередь не сможет добавить новый жлемент, если она строго ограничена, например, на 2 элемента. В таком случае, вызов метода `add`, когда он не может выполнится, будет приводить к ошибке. Поэтому более подходящий способ добавить элемент в очередь - это метод `offer`. Отличие в том, что он не будет кидать исключение, если очередь не сможет добавить себе новый элемент. Он будет возвращать ответ (да или нет), смогли ли мы добавить в очередь новый элемент.

Мы не можем запрашивать очередь дать нам элемент n, поскольку для очереди они не обязательно имеют какие то номера. Все что важно для очереди - это если мы будем спрашивать очередь "дай мне следующий элемент" - то она должна отдавать его нам. Аналог - живая очередь, где все люди узнали, кто за кем идет - и разошлись. Мы не можем сказать очереди "а кто идет 105-м"?

Чтобы получить следующий элемент, мы можем использовать метод `element`. Но если элементов не будет (очередь пуста) - упадет с ошибкой. Так что чаще всего вытаскивают элемент через метод `poll`. По сути, этот метод изымает элемент из очереди и отдает его в качестве возвращаемого значения, если элементов в очереди нет - возвращается налл.

Очередь - это живая коллекция, мы можем добавлять/изымать элементы в произвольном порядке. Есть мы хотим просто посмотреть следующий элемент, не изымая его - есть метод `peek`.

Так как очередь - коллекция, то проверять на пустоту очереди, сравнивая `peek` с наллом, будет неправильно. Проверять нужно методом `isEmpty`
```java
while (!queue.isEmpty()) {
    String s = queue.poll();
    System.out.println(s);
}
```
Очередь не обязана выдавать из себя элементы в том же самом порядке, в котором мы их туда добавляли. Это зависит от реализации очереди, если мы поменяем - поменяется и порядок. Ведь все, что требуется от реализации очереди - это возможность добавлять элементы в очередь и возможность опрашивать очередь, а кто пойдет следующим. Например, `PriorityQueue` выдает элементы не в порядке добавления, а просто в том порядке, в котором она сравнивает элементы (от маленького до большого) `Queue<String> queue = new PriorityQueue<>();`. Мы можем реализовать такую очередь с любымти элементами, которые реализуют интерфейс `comparable`, либо же указав в PriorityQueue копаратор, которым она бы сравнивала элементы. [Дока](https://docs.oracle.com/javase/8/docs/api/java/util/PriorityQueue.html)

Также очереди (так как являются частным случаем коллекций) обладают всеми стандартными методами интерфейса collection

коллекции из очередей обычно используются там, где мы в реальной жизни хотели бы использовать очередь. Например, очередь на обработку элементов/очередь клиетом на обслуживание. Мы сами выбираем логику сравнения, которую мы хотим использовать внутри очередь (фифо или какие то приоритеты (например, клиеты бизнес класса обслуживаются в первую очередь)).

Вставка элемента в конец очереди и извлечение элемента из её начала константно O(1).

Как уже говорилось ранее, Queue — это интерфейс, описывающий контракт однонаправленной очереди без какой-либо реализации. Стандартная библиотека Java предоставляет разработчикам реализацию этих методов по умолчанию с помощью класса AbstractQueue, который, в свою очередь, реализует все методы интерфейса Queue. [Документация](https://docs.oracle.com/javase/8/docs/api/java/util/AbstractQueue.html) Class AbstractQueue<E>, На основе класса AbstractQueue в стандартной библиотеке Java реализованы следующие типы очередей:
- ArrayBlockingQueue
- ConcurrentLinkedQueue
- DelayQueue
- LinkedBlockingDeque
- LinkedBlockingQueue
- LinkedTransferQueue
- PriorityBlockingQueue
- PriorityQueue
- SynchronousQueue

## Деки и стэки

Рассмотрим двунаправленные очереди (которые могут работать с обеими концами) и стеки, которые работают с одним концом на добавление/удаление элементов. Интерфейсом, объединяющим двунаправленные очереди, является deque (double-ended queue или дек). Интерфейс дека является  дженерик интерфейсом
```java
import java.util.LinkedList;

public class Main {

    public static void main(String[] args) {
        Deque<String> s = new LinkedList<>();
        s.push("Petya");
        s.push("Olya");
        s.push("Tanya");
    }
}
```
Двунаправленная очередь отличается от однонаправленной тем, что в случае обычной очереди у нас очередь получалась слишком абстрактной. Мы просто туда добавляли элементы и потом, когда хотели извлечь элемент, просто приходили в очередь и говорили "кто следующий?". Нас не волновало, как они внутри организованы. Здесь же у нас уже будет 2 конца - можем добавлять как на один, так и на другой конец, а также снимать. При этом мы ожидаем что все это будет в том же порядке, в котором мы добавляли в концы. Поэтому у нас будут дублироваться многие методы - например, `offerFirst`, `offerLast`. При этом мы обычно вставляем в очередь в конец, поэтому `offer` == `offerLast`, `poll` == `pollFirst`.

[LinkedList](https://docs.oracle.com/javase/8/docs/api/java/util/PriorityQueue.html) - не единственная реализация для дека. В джаве есть класс ArrayDeque `Deque<String> s = new ArrayDeque<>();`. Внутри себя он хранит массив, когда мы вставляем новый элемент - используется идея циклического массива. Например, если у нас есть массив `_ _ _ 1 3 5 6`, если мы сейчас попытаемся добавить новое число (напр, 7) справа, то джава не будет копировать все элементы текцщего массива и вставлять в новый, а вставит на пустое место слева `7 _ _ 1 3 5 6`. Если уже и запас закончится - то будет уже создаваться новый массив.

ArrayDeque в среднем работает гораздо быстрее чем LinkedList. Вставка в любой конец очень быстрая. На основе интерфейса Deque в стандартной библиотеке Java есть коллекции:
- ArrayDeque
- ConcurrentLinkedDeque
- LinkedBlockingDeque
- LinkedList

Иногда нам хочется представить себе очереди лифо (как стопка книг - последнее добавленное будет первым на выход). Для таких ситуация есть класс Stack - это дженерик класс, так что мы должны указать тип элемента `Stack<String> s = new Stack<>;`. Кроме того, мы хотели бы оперировать терминами не "добавить" на стопку, а "положить" - поэтому если мы общаемся со стеком как со стопкой, то нужно использовать метод `push` (чтобы снять элемент со стопки - есть метод `pop`). 

Джава не рекомендует напрямую использовать тип данных Stack, вместо этого лучше инпользовать интерфейс Deque, в качестве реализации - `ArrayDeque`, все остальные методы и так в `Deque` будут, потому что его методы работают со стопками. Поработаем с стэком в цикле
```java
import java.util.ArrayDeque;
import java.util.Deque;
import java.util.LinkedList;
import java.util.Stack;

public class Main {

    public static void main(String[] args) {
        Deque<String> s = new ArrayDeque<>();
        s.push("Petya");
        s.push("Olya");
        s.push("Tanya");

        while (!s.isEmpty()) {
            String name = s.pop();
            System.out.println(name);
        }
    }
}
```
Класс Stack реализован на основе класса Vector. В этом его недостаток, так как все операции в классе Vector синхронизированные, а значит медленные