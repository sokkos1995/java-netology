# Generic

Дженерики - механизм обобщения кода классов.

## Generic классы и методы

Как мы можем шаблонизировать джава-классы чтобы использовать их в различных ситуациях, при этом не теряя мощности проверок типов в джаве. Напишем класс, который принимает на вход другие объекты и в итоге отвечают на вопрос - какой последний объект был сохранен в них (остальные может забывать)
```java
public class Memory {
    protected String value;

    public void save(String value) {
        this.value = value;
    }

    public T getLast() {
        return value;
    }
}
```
Как мы можем пользоваться этим классом
```java
public class Main {

    public static void main(String[] args) {

        Memory memory = new Memory();
        memory.save("Petya");
        memory.save("Olya");

        String value = memory.getLast();
    }
}
```
Если мы захотим использовать объекты и других классов (отличных от стринг), то возникнут проблемы. Нужно либо копировать класс (создавая по копии для каждого случая) - но это дублирование кода и не всегда возможно. Также можно ослабить типы (поставить тип Object вместо String) - но при попытке сохранить в переменную у нас возникнет ошибка! Дажде такой способ `String value = (String) memory.getLast();` будет не очень хорошим - джава хочет чтобы джава всегда проверяла всю корректность системы типов.

Решением будут Дженерики. Мы можем завести специальный список параметров, который будет применяться к самому классу. То есть везде, где мы будем использовать класс - мы будем передавать еще аргументы. Этот список параметров предназначен не для каких то конкретных значения в виде числа или какого то объекта - сюда мы будем передавать типы
```java
public class Memory<T>{
    // <T> - параметр, тогда везде мы можем указывать Т вместо конкретного типа
    protected T value; 

    public void save(T value) {
        this.value = value;
    }

    public T getLast() {
        return value;
    }
}

```
При использовании в будущем внутри нашего класса мы просто будем вместо Т подставлять конкретный тип, с которым мы хотиим иметь дело. Такие классы называются дженерик классами и нам следует всегда использовать их уже с этим списком параметров
```java
public class Main {

    public static void main(String[] args) {
        Memory<String> memory = new Memory<String>();  // String указываем не только при создании, но и везде при обозначении типа ячейки!
        memory.save("Petya");
        memory.save("Olya");
        memory.save("Tanya");
        String value = memory.getLast();
    }
}
```
Мы написали класс и можем его исчпользовать единожды для разных типов данных. Мы можем его использовать для любого класса. При этом мы не ослабили проверку типов.

Так мы можем указывать несколько тип-параметров `public class Memory<T, U>` - тогда этот тип тоже нужно будет указывать при создании, через запятую. Этот тип может участвовать у нас как то в логике конкретного класса.

Механизм дженериков не огбязательно использовать на уровне класса - мы можем его использовать на уровне обычных методов!
```java
public class Main {

    public static void main(String[] args) {
        Integer i = 100;
        Number n = i;

        Memory<String> memory = new Memory<String>();
        memory.save("Petya");
        memory.save("Olya");
        memory.save("Tanya");
        String value = memory.getLast();

        String v1 = "Petya";
        String v2 = "Olya";
        String result = choose(true, v1, v2);
        System.out.println(choose(true, i, v2));  // вернет число или строку
    }

    public static <T> T choose(boolean flag, T first, T second) {
        // если флаг - возвращаем первый объект, флага нет - возвращаем второй
        if (flag) {
            return first;
        } else {
            return second;
        }
    }
}

```
`public static <T> T choose(boolean flag, T first, T second)` - теперь у метода 2 списка параметров. В первом, стандартном списке - он принимает конкретно значения, с которыми он работает (`(boolean flag, T first, T second)`) , во втором списке параметров он в качестве значений принимает типы `public static <T>`

Метод - это 1 вызов программы, так что джаве хватит информации чтобы все понять, она не упадет во время компилирования.

Важной особенностью дженериков является то, что все проверки выполняются в момент компиляции. Все проверки в момент компиляции, а после нее - затирает всю ту информацию: которую мы указали в угловых скобках. Именно поэтому из-за того что джава в момент выполнения не будет знать, какой конкретно тип мы указали - мы не сможем указать конкретный тип через new (`String result = Main.<String>choose(true, v1, v2);`). В случае работы с дженерик методами это нормально - когда мы не указываем тип-параметры. В случае же работы с дженерик классами - всегда ставим угловые скобки `Memory<String> memory = new Memory<String>();`! Иначе такой тип называется raw type

## Generic и наследования

Особенности работы с дженериками, если мы их используем вместе с наследованием.

Первое, на что можем обратить внимание - мы могли бы предположить что здесь `Memory<String> memory = new Memory<String>();` в угловых скобках будет работать полиморфизм. К примеру, у нас есть класс `Integer` - и это по сути ссылочный аналог примитивного типа данных инт. Так как это ссылочных тип и является по сути обычным джавоским классом - он встроен в свою иерархию классов. Все ссылочные типы данных, которые описывают числа, в джаве объединяются под классом `Number`. То есть мы можем объявить переменную с типом Number и присвоить туда объект класса Integer
````java
    public static void main(String[] args) {
        Integer i = 100;
        Number n = i;
    }
```
Мы можем предположить что тогда полиморфизм сработает и на тип параметров тоже. Однако ничего компилиться не будет - джава запрещает использовать полиморфизм по линии дженериков. Джава запрещает указывать разные типы здесь в угловых скобках. Нужно и слева, и справа указать одно и то жэе. Но так как мы всегда указываем  одно и то же - справа можно опустить прописывание руками, оставить пустые угловые скобки.
```java
// Memory<Number> memory = new Memory<Integer>();  // тут ничего компилиться не будет
Memory<Number> memory = new Memory<>();
```
Также словом extends мы можем ограничить все типы, которые можем передать в метод, всеми типами, которыми расширяем Number (включая сам Number). Помимо extends мы можем указать слово super - тогда это будет проверка в обратную сторону.
```java
    public static <T extends Number> T choose(boolean flag, T first, T second) {
        if (flag) {
            return first;
        } else {
            return second;
        }
    }
```
На самом деле дженерики дают нам больше возможностей чем параметры без ограничений - ведь по сути мы сообщаем джаве дополнительную информациюб об этом параметре. Теперь джава знает, что Т - это всегда какой то потомок Number, а значит если нам пришло значение типа Т, то у него точно должны быть все методы, которые есть у Намбера (если бы писали без экстендз, то этих методов бы не было, ведь джава не знала бы, какой тип здесь может прийти).

Создадим интерфейс для нашего класса Memory. По сути, этот интерфейс будет говорить что любой класс, который его имплементирует, имеет объекты, у которых будет метод save. 
```java
public interface Savable<T> {
    void save(T obj);
}

public class Memory<T> implements Savable<T> {  // Savable<T> - это Т это конкретное значение типа, которое нам пришло в Мемори в виде параметра
    protected T value;

    public void save(T value) {
        this.value = value;
    }

    public T getLast() {
        return value;
    }
}
```