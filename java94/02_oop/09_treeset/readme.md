# TreeMap

Деревья поиска - структура данных, которая явлеяется основой для реализации таких интерфейсов как мап и сет.

## Comparable и компараторы 

Узнаем, как мы сможем сравнивать объекты в джаве между собой, на предмет кто из них больше, а кто - меньше.

Создадим собственный тип данных
```java
public class Person implements Comparable<Person> {
    protected String name;
    protected int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public int compareTo(Person o) {
        if (age < o.age) {
            return -1;
        } else if (age > o.age) {
            return 1;
        } else {
            return name.compareTo(o.name);
        }
    }

    @Override
    public String toString() {
        return name + " " + age;
    }
}
```
Для сравнения нам пригодится интерфейс `Comparable`. Если мы хотим, чтобы класс Person был такой чтобы мы могли сравнивать его объекты между собой (например, больше или меньше) - нужно указать, что этот класс реализует интерфейс `public class Person implements Comparable<Person>` (причем этот интерфейс дженерик, то есть в угловых скобках указываем тип элементов, которые мы хотим сравнивать). Теперь добавим метод, который позволит реализовать этот интерфейс - `public int compareTo(Person o)`. Сперва посмотрим на параметр и на то, как джава в принципе предполагает что мы будем использовать этот метод. Джава считает, что для того, чтобы сравнить 2 предмета между собой на предмет кто из них больше/меньше, джава возьмет один объект, вызовет у него метод `compareTo` и передаст туда другой объект. Тип возвращаемого объекта - инт (бул не подходит, тк возможны 3 варианта - меньше, больше, равны). Если меньше - то возвращаем любое отрицательное число, больше - любое положительное.
```java
public class Main {

    public static void main(String[] args) {
        Person p1 = new Person("Petya", 10);
        Person p2 = new Person("Tanya", 10);

        System.out.println(p1.compareTo(p2));
    }
}
```
Создадим список из людей
```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class Main {

    public static void main(String[] args) {
        List<Person> people = new ArrayList<>();
        people.add(new Person("Petya", 8));
        people.add(new Person("Tanya", 15));
        people.add(new Person("Olya", 8));
        people.add(new Person("Anya", 8));
        System.out.println(people);  // [Petya 8, Tanya 15, Olya 8, Anya 8]

        Collections.sort(people);  // [Anya 8, Olya 8, Petya 8, Tanya 15]
        System.out.println(people);
    }
}
```
`Collections` - класс, который содержит огромное количество вспомогательных методов для работы с коллекциями.

Мы научились учить джаву сравнивать объекты нашего класса. Однако тот порядок, который мы задаем - задается, по сути, единожды при создании самого класса. Что если мы хотим сравнивать объекты этого класса по какому то другому принципу? Здесь нам на помощь придет специальный интерфейс, который называется компаратор. Интерфейс компаратор по сути говорит что любой объект этого интерфейса предназначен для того чтобы сравнивать объекты какого то другого класса. К примеру, если мы хотим сравнивать объекты класса Персон по какому то другому принципу
```java
import java.util.Comparator;

public class PersonsNameLengthComparator implements Comparator<Person> {

    @Override
    public int compare(Person o1, Person o2) {
        return Integer.compare(o1.name.length(), o2.name.length());
    }
}
```
`implements Comparator<Person>` - именно компаратор, а не компарабл! Компарабл - говорит о том, что класс, который его имплементирует, его объекты умеют сравниваться между собой через компареТу. Компаратор же - это отдельный класс, предназначение которого - сравнивать объекты какого то другого класса.

Рассмотрим метод `compare`. В отличии от `compareTo` - у нас тут 2 параметра. Действительно, когда мы сравнивали 2 объекта через compareTo - одним из сравниваемых объектов был тот объект, у которого мы вызвали метод. Теперь же метод будем вызываться у объекта, который сам будет сравнивать, но сам не будет сравниваться с кем то другим. Поэтому те 2 объекта, которые ему надо сравнить - будут приходить к нему в параметры. Также `Collections.sort` может применять вторым параметром принцип, по которому мы будем сортировать - `Collections.sort(people, new PersonsNameLengthComparator());`. Тогда `Collections.sort` будет использовать не compareTo, а объект компаратора.
```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class Main {

    public static void main(String[] args) {
        List<Person> people = new ArrayList<>();
        people.add(new Person("Petya", 8));
        people.add(new Person("Tanya", 15));
        people.add(new Person("Olya", 8));
        people.add(new Person("Anya", 8));
        System.out.println(people);  // [Petya 8, Tanya 15, Olya 8, Anya 8]

        Collections.sort(people, new PersonsNameLengthComparator());  // [Olya 8, Anya 8, Petya 8, Tanya 15]
        System.out.println(people);
    }
}
```

## TreeSet, TreeMap

Узнаем о том, как мы может реализовать ассоциативный массив или множество на основе информации, как мы можем сравнивать объекты между собой. Для этого требуется познакомиться с таким теоретическим концептом как деревья. Если связный список представляется в виде набора объектов, где в каждом объекте у нас хранится информация, которую мы сохраняем в ячейку и каждый объект помнит, кто у него находится слева и кто находится справа - то дерево немного сложнее по структуре. У нас также есть ячейки, которые представляются в виде объектов. Внутри объекта лежит значение, которое мы кладем в ячейку. Однако ячейка помнит не левого и правого соседа, а левого и правого ребенка. Получив эти объекты ячеек, мы выстраиваем их в следующую стурктуру, она называется дерево. 

Дерево — это структура данных, состоящая из узлов и рёбер. Каждый узел соединён с другим узлом с помощью ребра. Существует хотя бы один узел, у которого нет ни одного входящего ребра. Он называется корнем. Узлы, у которых нет исходящих рёбер, называются листами.

На этой идее и строится структура, которая называется бинарное дерево поиска. Здесь накладывается следующее правило - у каждого объекта ячейки (которая обычно называется узлом) значение, которое лежит в узле, всегда больше тех зщначений, которые лежат слева от него и меньше тех, что лежат справа.

Если у нас элементы расположены в бинарном дереве поиска, то нам для поиска определенного элемента не нужно перебирать прям все элементы в этом дереве, Мы каждый раз просто выбираем путь, идти влево или вправо, время поиска в таком дереве ограничено его высотой. Самая частая реализация бинарного дерева - красно-черное дерево.

Как мы можем использовать идею бинарного дерева для реализации асоциативного массива? Мы можем взять и хранить в этих ячейках пары ключ-значение. Именно по ключу мы и будем сравнивать элементы в ячейках. 
```java
import java.util.Map;
import java.util.TreeMap;

public class Main {

    public static void main(String[] args) {
        Map<String, Integer> map = new TreeMap<>();
        map.put("Petya", 8);
        map.put("Tanya", 15);
        int age = map.get("Petya");
        System.out.println(age);
    }
}
```
Если класс ХэшМэп требовал от нас дополнительных условий на ключ, а конкретно - правильную реализацию хэш-кода (тк это была реализация на хэшах), то TreeMap будет требовать чтобы класс ключей корректно реализовывал метод `compareTo`. Либо же при объявлении мы должны указать компаратор. Это используется для того чтобы построить корректное дерево поиска.

Если мы посмотрим на иерархию классов, то у нас есть интерфейс мап и есть различные его реализации. Интерфейс СортедМап является частным случаем интерфейса Мап, он наследуется от него и по сути представляет собой все мапы, которые храняти ключи в отсортированном виде. Его подтипом является NavigableMap, по которому мы можем ходить, и уже реализацией NavigableMap (а соответственно, и СортедМап, и Мап) является ТриМап, который использует бинарные деревья поиска в качестве своей основы для хранения пар ключ-значения. Интерфейс СортедМап предоставляет нам дополднительные возможности к уже тем, которые есть в интерфейса Мап (минимальный/максимальный ключ, разрезать мапу по определенному ключу и тд)

Джава также предоставляет специальный класс, который реализует интерфейс множества, тоже основанный на деревьях. То есть мы можем создать сет от стринга и положить туда в качестве реализации ТриСет `Set<String> set = new TreeSet<>();`, храниться все будет в виде бинарного дерева поиска. Ограничения на значения тут такие же, как ограничения на ключи у TreeMap - они должны быть сравниваемые.

TreeMap гарантирует скорость доступа log(n) для операций containsKey, get, put и remove

Зачем ещё нужен [TreeMap](https://docs.oracle.com/javase/8/docs/api/java/util/TreeMap.html#tailSet(E))
1. Добавляет упорядоченное итерирование по ключу. Это нам необходимо, если нужно вывести элементы. Например, вызов toString на каждом value (варианты создания итератора: keySet().iterator() или values().iterator())
2. Даёт полезное свойство в отсортированной коллекции — возможность работать с диапазонами значений, используя методы subSet или tailSet
3. Используется в ряде задач, где требуется гарантированная скорость доступа O(log N).
4. Используется в задачах, где нет возможности соблюсти контракт HashCode и Equals. Например, при использовании объектов с неизменяемым HashCode

Отличия между TreeSet и HashSet
- HashSet не поддерживает никакого порядка хранения элементов, TreeSet применяет натуральную сортировку к элементам
- HashSet может хранить null-объекты, TreeSet не может
- HashSet для сравнивания элементов использует equals() и hashCode(), TreeSet использует compare() или compareTo()
- HashSet обеспечивает лучшую производительность — константную временную производительность для большинства операций add(), remove() и contains(). TreeSet обеспечивает log(n).
- TreeSet, благодаря методам pollFirst(), pollLast(), first(), last(), ceiling(), lower(), можно использовать более гибко

TreeSet используется, когда требуется эффективный способ сортировать по какому-то признаку или нескольким признакам большое количество уникальных элементов. Но следует держать в уме, что TreeSet немного медленнее HashMap.  
Если нет возможности задать «хорошую» хеш-функцию распределения объектов, то TreeSet может оказаться даже эффективнее.  
Также полезно использовать методы TreeSet — headSet, tailSet, subSet — при операциях поиска или выделения подмножества над сортированным множеством

Начиная с JDK 8 мы можем применять сразу несколько компараторов по принципу приоритета.