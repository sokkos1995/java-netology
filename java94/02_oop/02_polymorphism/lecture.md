## Полиморфизм

Рассмотрим, какие дополнительные возможности может дать джава при наследовании.

Дословный перевод: поли + морфизм = много форм (с русского на русский). Это способность объекта выглядеть, как его предок, но отличаться в поведении

Мы можем созздать ячейку с типом Person и хранить там значения типа Person. Это делается так `Person person = new Person("Petya", 8);`. Сперва может показаться, что это несколько избыточная конструкция, ведь и слева, и справа у нас Person. Однако джава на самом деле дает нам несколько больше возможности - на самом деле мы в ячейку класса Person можем поместить объект класса Singer `Person person = new Singer("Petya", 8, 4);`. Базовая идея тут такая - мы знаем, что Сингер у нас наследуется от Персон, по сути, певец - это частный случай человека. Когда мы заводим ячейку Человек, это означает что сюда мы можем класть людей. Это может быть как обычный человек, так и какой то частный случай, например, Певец.

Рассмотрим технические детали, что тут у нас произойдет. Мы не сможем вызвать метод сингера у такой переменной. Когда джава будет анализировать и компилировать код, она будет исходить из того что мы вызываем тот метод, которого на самом деле у объекта нет. Джава смотрим на тип ячейки и выбирает те методы, которые точно будут у того типа ячейки, который здесь лежит.
```java
public class Main {

    public static void main(String[] args) throws Exception {
        Person person = new Singer("Petya", 8, 4);
        person.sing("smth")  // не скомпилируется
    }
}
```
Все что джава учитывает - что в переменной person лежит какое то значение, которое мы в принципе можем туда положить. Набор доступных для переменной методов джава ограничивает, глядя на тип самой ячейки. При этом методы, которые мы наследовали - вызовутся дочернего класса!
```java
public class Main {

    public static void main(String[] args) throws Exception {
        Person person = new Singer("Petya", 8, 4);
        person.happyBirthday()  // Вызовется метод happyBirthday класса Singer, не Person
    }
}
```
Набор методов ограничивается типом самой переменной! Ведь джаве нужно убедиться что этот метод точно будет у того значения, которое мы вызываем. Версия же метода, которая будет вызвана, определяется по фактическому типу значения, которое там находится. Это называется Полиморфизмом

Рассмотрим длдя чего этот механизм нам нужен.
```java
public class Main {

    public static void main(String[] args) throws Exception {
        Singer singer = new Singer("Petya", 8, 4);
        Person person = new Singer("Petya", 8, 4);
    }

    public static boolean checkPerson(Person person) {
        return person.getAge() >= 18;
    }    
}
```
Если бы не было полиморфизма, мы бы не могли передать в метод checkPerson значения типа Singer! Ведь singer был бы типа Singer, а checkPerson принимает значения типа Person. Благодаря же полиморфизму мы можем передать значения типа Singer, ведь это работает не только для переменных - это работает для любых ячеек (для полей, для параметров, для локальных переменных и тд). Если где то ожидается что мы передадим тип предка, то мы можем туда на самом деле передать объект типа наследника.

Главный плюс тут в том, что мы можем пользоваться методами, которые написаны автором библиотеки. Автор не знал, что есть такой класс Сингер. Но с помощью полиморфизма мы можем пользоваться методами без необходимости в них заглядывать и чего то переписывать. Это получается благодаря тому что все, что использовал автор этого метода - это что то значение, которое будет передано в качестве параметра, подходит под правила полиморфизма, то есть является частным случаем.

## Применение

Напишем систему классов, которая бы имитировала музыкальный редактор. У нас будут различные инструменты, которые будут выводить разные символы на экран, но все инструменты будет объединять то, что они имеют играть, то есть они будут явно от одного класса.
```java
// базовый класс
public class Instrument {

    public char playSound() {
        return ' ';
    }
}
```
Для пианино это будет выглядеть так
```java
public class Piano extends Instrument {

    @Override
    public char playSound() {
        return '#';
    }
}
```

Теперь создадим класс, который будет описывать музыкальный трек. ДЛя этого создадим класс Song, у каждой песни будет несколько дорожек. По сути, мы хотим сделать следующее - каждый инструмент, который мы попросим сыграть, будет отдавать нам какой то уникальный символ. Каждая строка вывода в консоль будет соответствовать 1 секунде проигрывания, а каждый столбец - каждому инструменту. Так как инструментов у нас много, удобно использовать массив `protected Instrument[] instruments;`. КОгда мы создаем массив, мы указываем тип массива (все ячейки должны быть этого типа). Но благодаря полиморфизму мы можем кидать не только тип Инструмент, но и дочерние типы. Что касается того, должен ли инструмент играть - тут идеально подойдет двумерный массив, где первый индекс - номер инструмента, а второй - номер секнды. Значение - должен ли играть инструмент
```java
public class Song {
    protected Instrument[] instruments;
    protected boolean[][] shouldPlay;

    public Song(Instrument[] instruments, boolean[][] shouldPlay) {
        this.instruments = instruments;
        this.shouldPlay = shouldPlay;
    }    
}
```
Создавать массив инструментов будем так:
```java
public class Main {

    public static void main(String[] args) throws Exception {
        Instrument[] instruments = {
          new Guitar(),
          new Piano(),
          new Flute(),
          new Guitar()
        };

        boolean[][] shouldPlay = {
                { false, true, true, true, true, false },
                { true, false, true, false, true, false },
                { false, false, true, true, false, false },
                { false, true, true, true, true, false }
        };

        Song song = new Song(instruments, shouldPlay);
        song.play();
    }
}
```
Теперь перейдем к написанию самого метода. Сперва нам нужно определиться с длиной песни - `int time = shouldPlay[0].length;` (внутренние массивы все имеют одинаковую длину). Затем пройдемся глобальным циклом по всем секундам, по всем инструментам
```java
    public void play() throws Exception {
        int time = shouldPlay[0].length;
        for (int t = 0; t < time; t++) {
            for (int i = 0; i < instruments.length; i++) {
                if (shouldPlay[i][t]) {
                    Instrument instrument = instruments[i];
                    char c = instrument.playSound();
                    System.out.print(c + " ");
                } else {
                    System.out.print("  ");
                }
            }
            System.out.println();
            Thread.sleep(1000);
        }
    }
```
Out
```
  #     
$     $ 
$ # ! $ 
$   ! $ 
$ #   $ 
```
Мы могли сперва написать всего парочку инструментов, написать класс Song и отправить его для публичного использования. В этом и есть вся прелесть полиморфизма.