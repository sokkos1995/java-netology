## Абстрактные классы

Как мы можем обогатить понятие наследования на примере абстрактных классов. Создадим класс, который будет общий для видов транспорта
```java
public class Transport {
    private int fuel;

    public Transport(int fuel) {
        this.fuel = fuel;
    }

    public void spendFuel(int fuel) {
        this.fuel -= fuel;
    }

    public void transfer(String name, String from, String to);
}
```
Этот класс мы создаем не для того чтобы создавать от него объекты (потому что объекты будут достаточно бессмысленными) - мы хотим отнаследоваться от него и создавать различные виды транспорта. Так, создадим класс машины
```java
public class Car extends Transport {

    public Car() {
        super(100);
    }

    @Override
    public void transfer(String name, String from, String to) {
        System.out.println(name + " поехал на машине из " + from + " в " + to);
        spendFuel(10);
    }
}
```
По аналогии сделаем и другие классы - самолет, корабль.

Как мы будем использовать эти классы. Создадим перевозки
```java
public class Main {

    public static void main(String[] args) {
        String name = "Petya";

        Car car = new Car();
        spbToMoscow(name, car);

        Ship ship = new Ship();
        spbToMoscow(name, ship);

        Plane plane = new Plane();
        spbToMoscow(name, plane);
    }

    public static void spbToMoscow(String name, Transport transport) {
        transport.transfer(name, "SPB", "MSC");
    }
}
```
Благодаря полиморфизму мы можем вынести повторяющуюся логику просто в отдельный метод, 
```java
    public static void spbToMoscow(String name, Transport transport) {
        transport.transfer(name, "SPB", "MSC");
    }
```
В итоге мы 1 раз написали логику в методе spbToMoscow, который принимает ячейку transport типа Transport - и это у нас работает тк класс Transport является общим предком, включается полиморфизм. Есть и минусы такого дизайна. Первая проблема - ничто нам не помешает сделать объект класса Transport. Это нарушает философию ООП, мы считаем что программа - это набор объектов, которые сами по себе корректны, всегда сами отвечают за свое состояние (за свою память) и за те команды, которые они делают. Создатель класса Transport не подразумевал, что мы будет создавать объекты такого типа, он использовал этот класс только как общую основу для объектов. Никакой ошибки при попытке запустить код не будет! У нас действительно есть такой метод, хоть там и пустая реализация (мы создавали этот метод только для полиморфизма). 
```java
    Transport transport = new Transport();
    spbToMoscow(name, transport);
```
ПОлучается смешение логик и ролей классов. Если раньше изначально мы могли использовать классы как просто шаблоны для объектов, то в случае с наследованием классы получают еще одну роль - они являются основой для других классов. И именно только эту роль и должен выполнять класс Transport

С помощью области видимости private мы не сможем решить проблему, с помощью protected - лишь частично. Если кто нибудь создаст новый вид транспорта (самолет) и забудеть переопеределить метод transfer - у нас вызовется метод трансфер от класса Transport.  
Вызов ошибки вручную - тоже будет далеким от идеала решением, ведь у нас программа скомпилируется. Мы бы предпочли чтобы программа заранее, в моменте компиляции, подчеркнула нам это как ошибку. Именно это нам дает такой инструмент как абстрактные класса.

Еще раз подчеркнем 2 роли, которые играет класс в рамках ООП
- быть шаблоном для объектов
- быть основой для других классов через механизм наследования  
Мы бы хотели каким то образом сказать джаве, что наш класс играет только вторую роль, не первую. Так мы убиваем 2 зайцев - запрещаем создавать объекты этого класса и заставляем всех наследников давать конкретную реализацию. При этом мы будем использовать свойство полиморфизма - то есть мы хотим использовать этот класс в качестве базы для типов данных различных ячеек.
```java
public abstract class Transport {
    private int fuel;

    public Transport(int fuel) {
        this.fuel = fuel;
    }

    public void spendFuel(int fuel) {
        this.fuel -= fuel;
    }

    public abstract void transfer(String name, String from, String to);
}
```
- `public abstract class Transport` - джава будет сама следить, чтобы нигде не было объектов класса транспорт. При попытке создать объект джава ругнется что класс был объявлен как абстрактный.
- `public abstract void transfer` - позволяет объявлять методы без реализации (абстрактный метод). Тут - мы хотим использовать силу полиморфизма, но не хотим давать какую то конкретную реализацию. Мы хотим чтобы наши наследники уже давали реализацию этого метода, при этом прогарантировав что у всех наследников этот метод будет.

По сути все ограничения на работу с абстрактными методами будут направлены на то чтобы мы джаву никогда не поймали на просьбе выполнить тот метод, у которого нет реализации (подчеркнется красным объявление класса).

Не абстрактный класс - конкретный! Логика джавы: если класс не является абстрактным, значит ты теоретически можешь создать объект этого класса; если ты можешь создать объект этого класса, то методы у этого класса будут те, которые он получил в наследство. Но среди методов, полученных в наследство, есть один, которому забыли дать реализацию (абстрактный) (нарочно забыли). ДЖава от нас будет требовать дать реализацию этому методу. По сути, раньше, когда мы переопределяли метод, мы давали новую реализацию работы метода. Сейчас же у этого метода вообще нет версии работы - поэтому джава заставляет нас дать версию методу.

Абстрактный класс может спокойно иметь и конкретные методы, и поля, и конструкторы! Просто конструкторы мы не сможем напрямую вызвать через new - они всегда будут вызываться у наследников, через super.

Основные преимущества абстрактного класса:
- не может быть создан, а значит, не будет объектов с нереализованными методами
- обязывает потомков переопределить методы
- гарантирует наличие переопределённого метода в классе-потомке
- нет необходимости бросать исключения

## Интерфейсы

Добавим в систему еще один вид транспорта - велосипед. Велосипеду топливо не нужно, поэтому желательно сделать еще один уровень абстракции. По сути, класс Transport будет объединять все виды транспорта, которые используют топливо. Создадим еще один абстрактный класс, который будет объединять все виды транспорта. У него наследником будет Transport и класс ВЕлосипед, который будет конкретным видом средства передвижения.
```java
public abstract class Transferer {
    public abstract void transfer(String name, String from, String to);
}

public abstract class Transport extends Transferer {
    private int fuel;

    public Transport(int fuel) {
        this.fuel = fuel;
    }

    public void spendFuel(int fuel) {
        this.fuel -= fuel;
    }
}
```
Теперь добавим класс велосипеда
```java
public class Velo extends Transferer {

    @Override
    public void transfer(String name, String from, String to) {
        System.out.println(name + " прокатился на велике из " + from + " в " + to);
    }
}
```

Класс Transferer у нас получился настолько абстрактным, что у него вообще нет никаких конкретных членов класса. У Transport есть много конкретики - поле fuel, которое хранит в себе топливо, метод spendFuel. В случае же с классом Transferer все члены являются абстрактными. Для такого уровня абстракции в джаве есть специальный механизм и специальный вид класса. Настолкьо специальный, что он даже не класс - интерфейс. Интерфейс предполагает собой что у него нет ничего конкретного
```java
public interface Transferer {
    void transfer(String name, String from, String to);
}
```
Так как все методы абстрактные - уже становятся лишними модификаторы public и abstract. Еще одно изменение, которое нужно сделать - хоть джава и считает интерфейсы суперабстрактным классом, она делает наследование интерфейсов по отдельной линии. Если мы хотим сказать что Велосипед наследуется от Трансферера, то мы используем не extends, а implements. За этим скрывается некая философская подоплека - раньше мы использовали абстрактность как возможность недореализовать некоторые части программы (взять и объявить какой то метод, не дав ему реализации). По сути, это был какой то недоделанный класс, который должны были доделдать наследники. Однако в случае интерфейса у нас никакой конкретики в нем не находится. Любой наследник, который от него наследуется (или имплементирует == реализует), не получает никакой конкретики себе в багаж. Он получает лишь набор абстрактных методов, которые он должен реализовать, если сам является конкретным. В итоге мы смотрим на интерфейс не как на наследство, в котором мы должны заплатить какие то долги (дать реализацию ккаким то методам), а как список требований к классу, который заявляет что он него наследуются. Поэтому джава немного переосмыслила наследование интерфейсов и заявляет что класс Velo имплементирует (реализует) интерфейс. Класс Velo умеет выполнять все команды, которые находятся в списке требований интерфейса Transferer
```java
public class Velo implements Transferer {

    @Override
    public void transfer(String name, String from, String to) {
        System.out.println(name + " прокатился на велике из " + from + " в " + to);
    }
}
```
В итоге мы получаем систему классов разного уровня абстракции.

Интерфейсы настолько суперабстрактные (ведь там нет никаких полей, конкретных методов), что джава разрешает наследовать несколько интерфейсов в рамках класса
```java
public interface Billable {
    void pay(int amount);
}

public abstract class Transport implements Transferer, Billable {
    private int fuel;

    public Transport(int fuel) {
        this.fuel = fuel;
    }

    public void spendFuel(int fuel) {
        this.fuel -= fuel;
    }

    @Override
    public void pay(int amount) {
        System.out.println("Уплачено в размере " + amount);
    }
}
```

Абстрактные классы:
- могут хранить состояние (поля) и описывать поведение (методы)
- описывают сходные по свойствам классы  
Наследовать несколько абстрактных классов нельзя.

Интерфейсы:
- описывают только поведение (методы)
- могут быть реализованы на абсолютно разных классах  
Класс может реализовывать несколько интерфейсов

Java-класс может наследоваться только от одного класса. Это сделано, чтобы избежать проблемы ромбовидного наследования.  
Когда классы B и C наследуют класс А и класс D наследуется от них обоих, возникает проблема неопределённости: методы в В и С могут быть переопределены по-разному. Считается, что если в вашей программе требуется множественное наследование, нужно пересмотреть архитектуру и, возможно, использовать интерфейсы 