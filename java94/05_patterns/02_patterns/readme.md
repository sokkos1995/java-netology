# Порождающие, структурные и поведенческие шаблоны

## Структурный шаблон Flyweight

Хотя композиция (оборачивание) - это важный прием в структурных шаблонах, но он не единственный.

Если людей много, а вариаций имён мало, у нас будет очень много копий, т.е. трата памяти. Если не хранить имена в Person, то будет нарушение принципов ООП — имя принадлежит и связано с конкретным человеком, оно должно быть внутри. Логично хранить имя человека в объекте человека.
```java
// здесь шаблон не применен 
public class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    public String getName() {
        return name;
    }
    public int getAge() {
        return age;
    }
}
```
Изменим структуру объекта, чтобы не хранить копии имён, при этом оставив информацию об имени человека внутри его объекта
```java
public class Person {
    // создадим статический список из этих имен
    private static final List<String> NAMES = List.of("Petya", "Vasya", "Alex");

    private int nameNum;
    private int age;

    public Person(String name, int age) {
        // хранить мы будем имя как номер в списке
        this.nameNum = NAMES.indexOf(name);
        this.age = age;
    }
    public String getName() {
        // если у человека спрашивают имя - он смотрит на этот номер и из списка
        // вынемает соответствующее имя
        return NAMES.get(nameNum);
    }
    public int getAge() {
        return age;
    }
}
```
Flyweight == вес мухи. То есть легковес. 

## Поведенческие шаблоны: Command, CoR, Observer

Тут мы будем часто сталкиваться с функциональным программированием - как раз оно заточено на действия с командами.

### Шаблон Command (Команда)

Обращаемся с действиями как объектами. Объектам у нас соответствуют какие то предметы, когда мы хотим обращаться с действиями как с предметами - то пользуемся этим шаблоном.
```java
// заводим функциональный интерфейс Command с методом execute
public interface Command {
    // тут нет никаких параметров! С точки зрения этого шаблона, действие -
    // это то, к чему мы можем прийти, сказать выполниться, и оно выполнится.
    // Оно не потребует от нас каких то дополнительных данных. Если действие 
    // требует от нас дополнительных данных, то это не действие, а шаблон 
    // действия (то есть описание действия еще не завершено).
    void execute();
}
```
В отличие от функционального программирования считаем действиями только то, что можно вызвать без параметров
```java
public static void main(String[] args) {
    // создаем список, параметризированный этим функциональным интерфейсом, и нашими
    // тремя действиями реализуем этот интерфейс
    // то есть берем и в список добавляем действия - но через реализацию функционального интерфейса
    // потом что напрямую метод мы не можем добавить в список, мы можем добавить объект
    // джава позволяет это делать так, что этими действиями мы реализуем функциональный интерфейс.
    List<Command> commands = new ArrayList<>();

    commands.add(() -> System.out.println("Command 1"));
    commands.add(() -> System.out.println("Command 2"));
    commands.add(() -> System.out.println("Command 3"));
    for (int i = commands.size() - 1; i >= 0; i--) {
        commands.get(i).execute();
    }
}
```

### Шаблон СoR (Chain of responsibility)

Цепочка зависимостей. Допустим, у нас есть консальтинговое бюро в области юриспрунденции. Но областей права очень много. Мы не можем быть экспертов во всех областях. КОгда к нам приходит клиент, он думает, что мы являемся экспертами во всех областях. Что мы можем сделать
- выучить все право (что очень сложно)
- нанять по эксперту в каждой области права. Когда к нам приходят с запросом - мы просто идем по порядку по этим людям и у каждого спрашиваем.  
Для наблюдателя будет казаться что мы являемся экспертами, но по факту мы просто разделили ответственность на части, выстроили в цепочки и объединили логику как будто бы в единую. Это и есть цепочка зависимостей - мы не пишем единую логику, а разбиваем на части.

Разделяем единую большую логику на цепочку небольших логик. Упрощаем архитектуру, делаем более динамичным контроль над ней 
```java
public class Main {
    public interface Processor {
        // каждый обработчик просто принимает имя
        boolean pass(String name);
    }
    public static final List<Processor> PROCESSORS = List.of(/*...*/);

    public static void main(String[] args) {
        String name = "Vasya Petrov";
        // чтобы проверить какого то человека, мы можем просто пройтись циклом по 
        // этим обработчикам
        for (Processor processor : PROCESSORS) {
            if (!processor.pass(name)) {
                System.out.println("Не прошёл");
                return;
            }
        }
        System.out.println("Прошёл");
    }
}
```
Чтобы не писать огромную логику, просто разделяем ее и оборачиваем в цепочку, причем делаем это через ООП - у нас есть списко, можем проходить по нему в любом порядке, отсортировать его и тд.

### Шаблон Observer (Наблюдатель)

У нас есть какие то объекты, в них могут происходить какие то логические события. Мы бы хотели чтобы к этому событию у нас была привязана какая то реакция. Чаще всего это применяется в графических интерфейсах - при нажатии на кнопку происходит какое то действие. Чаще всего у этой кнопочки есть существующий в памяти программы объект, если кто то нажимает на эту кнопочку - этот объект обязуется выполнить какие то действия, которые его заранее попросили (то есть такой наблюдатель за конпкой). Как его реализовать? Здесь нам опять же поможет функциональное программирование. 

Когда логику реализации удобно выражать в терминах «событие», «источник события» и «обработчик». Подписываемся на нужные события необходимыми обработчиками
```java
public class MainCommandPres {
    public static class Emitter {  // Emitter - излучатель
        private List<Consumer<String>> subscribers = new ArrayList<>();

        public void subscribe(Consumer<String> s) {
            // создаем метод subscribe (подписаться), куда мы будем передавать действие.
            // Передавать действие мы будем в виде функционального интерфейса Consumer от 
            // стринга. Он описывает такое действие, которое принимает стринг, что то с ним делает 
            // и ничего не возвращает.
            subscribers.add(s);
        }
        public void say(String msg) {
            // КОгда мы вызываем этот метод, он выводит в консоль "я говорю " + сообщение 
            // пробегаемся по списку подписчиков и у каждого вызовем метод accept
            System.out.println("I say " + msg);
            subscribers.forEach(s -> s.accept(msg));
        }
    }
    public static class R {
        public void refute(String msg) { System.out.println("No! " + msg + " is false!"); }
    }
}

public static void main(String[] args) {
    R r = new R();
    Emitter emitter = new Emitter(); emitter.subscribe(r::refute);
    emitter.subscribe(msg -> System.out.println(msg.toUpperCase() + "!!!"));
    emitter.say("Earth is round");
}
```
Вернуться после функционального программирования

## Поведенческий шаблон Iterator 11:30

Самый популярный шаблон.

Iterator позволяет последовательно перебирать элементы набора без необходимости знать его внутреннюю структуру. Итератор — это интерфейс объекта-проводника по набору, который с помощью команд «есть ли что ещё посмотреть» и «покажи следующий элемент» позволяет его обойти

Цикл foreach - синтаксический сахар к итератору. Если бы итератора не существовало - пришлось бы разбираться, как внутри устроен хэшсет, и ходить по нему внутри. Это плохо тем, что нарушает принцип инкапсуляции. То, как устроен хэшсет - это личное дело хэшсета. Даже если наплевать на инкапсуляцию - нам все равно придется изучать эти поля. 

Можно реализовать следующую вещь. Допустим, у нас есть город и мы хотим пройтись по всем барам в нем. Карты города нет, но есть проводник, который отвечает на 2 вопроса - где находится следующий бар и есть ли еще бар, который мы не посетили. Таким образом мы с этим гидом можем посетить все, при этом мы не обязаны разбираться, как город выглядит. То же самое и итератор - это гид по самому набору

В джаве итератору соответствуют 2 интерфейса. Iterable - то интерфейс, который реализует сам набор (если набор предоставляет итератора, то он реализует Iterable). Iterable - это то, по чему можно проходиться. Он потребует реализации одного метода и это метод итератор
```java
@NonNull
@Override
public Iterator<String> iterator() {
    return new TodosIterator(primary, secondary);
}
```
если я даю возможность по себе проходиться, я должен реализовать метод итератор, который возвращает гида по этому тудуз. Через лямбду реализовать итератор не получится, так как нам нужно 2 метода - next и hasNext. А лямбдой реализуются только функциональные интерфейсы, то есть там реализуем только 1 метод. Здесь нам поможет анонимный класс