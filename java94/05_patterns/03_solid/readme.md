# Свойства хорошего кода. SOLID

## Магические числа

Это когда у нас есть глобальная константа, значение которой мы используем в коде напрямую. Это лучше выносить либо в именованные константы (статические финальные поля), либо выражать через что то другое.

У программы может быть множество количественных параметров: количество товаров в магазине, размер команды в онлайнигре, минимальная плата за обслуживание. Все эти значения мы так или иначе используем в нашем коде.   
**Правило Magic: не используй числа напрямую в коде.**.  
Не используйте значение параметра в коде напрямую, заведите для этого отдельную константу и обращайтесь к ней по имени. Можете также вместо константы обратиться к другому осмысленному выражению в вашей программы. Это сделает ваш код понятнее для чтения, адекватнее по содержанию и поможет избежать частых ошибок при её редактировании. Числа не должны появляться в коде “магически”!

Проблема магических чисел - легко допустить ошибку, изменив этот параметр. Эту ошибку может быть очень тяжело поймать.

Пример - у нас есть ассортимент товаров и цены, мы спрашиваем у пользователя, сколько и какого товара он хочет приобрести.
```java
class Main {
    static void main(String[] args) {
        String[] products = {"Молоко", "Хлеб", "Горчица"};
        int[] prices = {100, 50, 40};
        
        // int[] basket = new int[3];  // так лучше не делать!!!
        int[] basket = new int[products.length];
        Scanner scanner = new Scanner(System.in);
        while (scanner.hasNextInt()) {
            int productNumber = scanner.nextInt();
            int productCount = scanner.nextInt();
            basket[productNumber - 1] += productCount;
        }
        // for (int i = 0; i < 3; i++) {  // так лучше не делать! 
        for (int i = 0; i < basket.length; i++) {
            if (basket[i] > 0)
                System.out.println("Вы купили " + products[i] + " за " + (basket[i] * prices[i])
            );
        }
    }
}
```
Теперь добавление новых товаров в массивы products и prices не приведут к ошибке, тк не требуют исправлений во всех местах числа 3 на 4 (и во всех ли? в каждом месте нам надо было бы ещё призадуматься, означает ли число 3 тут количество товаров или что-нибудь ещё!).

## Don’t Repeat Yourself

Это значит просто не повторяться. Повторяющуюся логику лучше куда то вынести. Так и читаь код проще (не нужно так вчитываться и искать отличия), и писать.

Часто наша программа в разных местах делает либо одни и те же вещи, либо очень похожие вещи. Особенно это актуально, когда мы пишем новый кусок кода через копирование и вставки другой части нашего же кода, возможно с несколькими поправками.

Правило DRY (Don’t Repeat Yourself): не повторяй свой код. Видите повторяющиеся или похожие вещи? Возможно, пришло время создать новый метод! Вынесите туда повторяющийся кусок кода. Если код повторяется не с точностью, то стоит подумать о создании параметров к вашему методу, которые заключали бы в себя эту вариативность.

Теперь повторяющаяся логика вывода матрицы на экран вынесена в отдельный метод - код выглядит компактней, понятнее и в любой момент когда мы захотим вывести матрицу нам достаточно будет лишь вызвать метод, а не копировать кусок кода. Изменение логики вывода на экран теперь тоже удобнее: изменить придётся лишь в одном месте - метод - а не в каждом месте использовании как было до.

Пример не стал выписывать

## SOLID

Набор из 5 принципов, переводится как твердый, надежный

SOLID - это аббревиатура, которая обозначает пять принципов ООП и проектирования. (как и все принципы, это скорее приемы - не надо их везде и по максимуму применять)
- S - принцип единственной ответственности (Single Responsibility Principle). Класс должен выполнять только те функции, для которых он логически предназначен.
- O - принцип открытости/закрытости (Open Closed Principle) - Программные сущности должны быть открыты для расширения, но закрыты для модификации.
- L - принцип замены Барбары Лисков (Liskov Substitution Principle) - Наследуй только тогда, когда можешь играть роль за предка.
- I - принцип сегрегации (разделения) интерфейса (Interface Segregation Principle) - Много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения.
- D - принцип инверсии зависимостей (Dependency Inversion Principle) - Всё зависит от абстракций (интерфейсов), а не от деталей реализации друг друга.

### Single-Responsibility principle

Мы уже знаем, что не обязаны писать весь код нашей программы в одном файле - мы можем создавать сколько угодно разных классов, каждый в своём собственном файле. Это здорово, мы же не хотим хранить тысячи строк нашей программы в одном гигантском файле. Но это ли единственная мотивация и принцип разделения программы на классы?  
**Принцип единственной ответственности - каждый делает только то, для чего он предназначен.** Мы разделяем программу на пакеты, классы и прочие блоки не только для сокращения объёмов отдельных файлов, но для логического разделения. Например, класс Bird описывает то, что умеет птица, но не описывает то, на какой этаж едет человек, чтобы взять из дома хлеба ей покрошить. Класс должен выполнять только те функции, для которых он логически был создан, и все относящиеся логически к нему функции должны находиться в нём

Пример
```java
// так не надо
class Calculator {
    int calculate(String formula) {}

    void sendResultByEmail(int result, String email) {
        //...
    }
}

// так лучше
сlass Calculator {
    int calculate(String formula) {}
}

class EmailNotifier {
    void sendResultByEmail(int result, String email) {
        //...
    }
}
```
Задача калькулятора считать математические формулы, выдавая в качестве результата число, но уж точно не отправлять этот результат по почте - эту логику необходимо вынести из класса калькулятора в отдельный класс, ведь логически это разные задачи.

### Open-Closed principle

С помощью наследования мы можем научить новые классы всему тому, что умел исходный, но также добавить новые поля и методы - и всё это не меняя исходный класс. Например, нет необходимости мерчендайзера учить выставлять йогурты отдельно для каждого конкретного производителя, можно научить выставлять йогурты в принципе, тогда нам не нужно будет его переучивать если ассортимент производителей расширится.

Принцип открытости/закрытости - программные сущности должны быть открыты для расширения, но закрыты для модификации. Сущности (например, классы) должны быть открыты для расширения и закрыты для изменения. Мы должны стремиться писать код так, чтобы добавить новую функциональность было легко (например, наследованием), не меняя исходные классы.
- открыты для расширения - чтобы мы могли достаточно легко расширять функционал 
- закрыты для модификации - чтобы мы не редактировали при этом этот класс.

Пример из жизни - мы расширяем функционал нашего телефона, устанавливая приложения. Это не модификация - мы не вскрываем корпус и не лезем в основы ОС. Модифицировать - это всегда плохо. Нам нужно разбираться, как это устроено и всегда есть риск что то сломать. Мы стараемя всегда скрывать детали и пользоваться по назначению.

Пример - сделаем класс, описывающий квадрат, и сумматор площадей
```java
// не правильно

class Square {
    double a;
    Square(int a) { this.a = a; }
    double area() { return a * a; }
}
class AreaSummator {
    double area = 0;
    void add(Square s) {
        area += s.area();
    }
    double sum() { return area; }
}

// Добавляем класс Circle

class Square { ... }
class Circle {
    double r;
    Circle(int r) { this.r = r; }
    double area() {
        return Math.PI * r * r;
    }
}
public static class AreaSummator {
    // Придётся менять для того чтобы он работал и с Circle
}


// Правильно
interface Areable {
    double area();
}
class Square implements Areable { ... }
class AreaSummator {
    double area = 0;
    void add(Areable s) { area += s.area(); }
    double sum() { return area; }
}

// Добавляем Circle

class Main {}
interface Areable {
    // создаем интерфейс для всех объектов с площадью
    double area();
}
class Square implements Areable { … }
class Circle implements Areable { ... }
class AreaSummator {
    // класс сумматор пишем так, чтобы он принимал любые объекты, измеримые по площади
    // Не требует изменений!
}
```
Теперь добавление нового типа фигур с площадью не требует изменений в классе подсчёта суммы площадей: мы можем расширять функциональность сумматора не изменяя его код, а добавляя новые классы реализаций.

Часто такой принцип можно увидеть во фреймворках. Библиотека - просто набор полезных классов, а фреймворк - это каркас приложения. Расширяя его, мы создаем наше приложение. При этом мы не лезем, не меняем код самого фреймворка. Мы просто его используем.

### Liskov substitution principle

Наследуйся только тогда, когда можешь играть роль за предка. Наследование изначально казалось лишь способом избежать лишних повторений. Но это лишило бы смысла полиморфизм. При полиморфизме мы можем положить объект дочернего класса в объект родителького класса. Это имеет смысл только тогда, когда наследники играют роль за своего предка.

Наследование в ООП - это не просто "технический хак" копирования полей и методов, это целая философия. Наследники расширяют и/или модифицируют возможности классов своих предков, наследники могут заменить своих предков в местах, где требуется предок.

Принцип замены Барбары Лисков - наследуй только тогда, когда можешь играть роль за предка.  
Наследники должны логически иметь возможность сыграть роль своих предков там, где требуются объекты предков - ведь они наследники! Поэтому если игрушка похожа на утку, крякает как утка, но нуждается в батарейках - возможно вам надо дважды подумать прежде чем считать её наследником утки, птицы и животного вообще

Пример
```java
// не правильно
class Logger {
    void log(int value) {
        System.out.println("Logging value to console: " + value);
    }
}

class Calculator extends Logger {
    void sum(int a, int b) {
        System.out.println("+: " + (a + b));
    }

    @Override
    void log(int value) {
        System.out.println("log: " + Math.log(value));
    }
}

// правильно
class Logger {
    void log(int value) {
    System.out.println("Logging value to console: " + value);
    }
}

class Calculator {
    void sum(int a, int b) {
        System.out.println("+: " + (a + b));
    }
    @Override
    void log(int value) {
        System.out.println("log: " + Math.log(value));
    }
}
```
У обоих классов есть метод `log(int value)` , но в случае калькулятора это подсчёт логарифма переданного значения с выводом результата на экран, а в случае логгера это логирование числа в консоль - совпадение сигнатур методов чисто случайны, логически они никак не связаны, логгер не является расширением понятия кулькулятор, как и калькулятор не является расширением понятия логгера, поэтому они не должны быть связаны отношением наследования.

### Interface segregation principle

Принципе сегрегации (разделения) интерфейсов. Разделяй большие интерфейсы на маленькие - не надо делать какие то суперуниверсальные интерфейсы. Вполне возможно, что если там намешано много функционала - нам понадобится лишь часть этого функционала.

Представим себе, что мы купили зарядку, которая подходит для разных моделей телефона, ноутбука и так далее. Будет ли правильно если мы не сможем зарядить наш андроид-телефон если контакт зарядки ноутбука поломался?

**Принцип сегрегации (разделения) интерфейса - разделяй большие интерфейсы на маленькие**

Много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения. Если у вас есть сложный объект, умеющий много разных функций, то будет неправильно заключить всех их в один большой интерфейс: клиент не должен зависеть от функций, которых он не использует, поэтому лучше создать набор различных логически разделённых интерфейсов вместо одного большого

Например, у нас есть класс Device, описывающий устройство, и класс Mobile, который имплементирует этот интерфейс. Устройство умеет много всего, но для некоторых вещей нам нужно только часть функционала. Поэтому есть идея разделить это на 3 однометодных интерфейса (в реальности, конечно, до такого лучше не доводить).
```java
// так не правильно
interface Device {
    void setAlarm(String time);
    void sendSMS(String msg, String number);
    void playMusic(String query);
}

class Mobile implements Device {
    ...
}

// так правильно
interface Clock {
    void setAlarm(String time);
}
interface SMSer {
    void sendSMS(String msg, String number);
}
interface MusicPlayer {
    void playMusic(String query);
}
class Mobile implements Clock, SMSer, MusicPlayer {
    ...
}
class SmartWatch implements Clock, MusicPlayer {
    ...
}
```
Теперь вместо одного гигантского интерфейса есть несколько различных логически независимых. Теперь, если мы захотим в метод получить объект, умеющий выставлять будильник, нам не надо будет требовать от него умения отправлять SMS!

Пример, когда джава сама нарушает этот принцип. В джаве есть семейство коллекций Unmodifyable (неизменяемые, их нельзя менять после создания). Мы можем создать эту коллекцию, использовать метод `iterator` - и нам вернется итератор, имплементирующий интерфейс Итератор. У этого итератора можно вызвать метод `remove`. У нас все скомпилиться, но при запуске вылетит - итератор имплементирован так, что метод `remove` кидает исключение, потому что его там быть не должно. То есть джава не стала делать отдельный интерфейс для неизменяемой коллекции и усложнять систему типов. Она просто сказала - я буду использовать то же самое, но если кто то это вызовет - выпадет исключение. Это хуже, так как мы откладываем обнаружение проблемы до запуска кода: а не на этапе написания программы. Зато выигрываем в простоте

### Dependency inversion principle

Принципе инверсии зависимостей. 

Сложные системы состоят из частей попроще - например, работающая лампа состоит из самого устройства, провода, проводки. Но правильно ли будет подключить утюг к электричеству спаивая его провода к проводке? Или достаточно просто знать, что если мы воткнём штекер в розетку, то пойдёт электричество?

**Принцип инверсии зависимостей - зависьте от абстракций, а не от имплементаций**. Традиционно, представляя сложные системы состоящими из более простых частей, мы добавляем зависимость высокому уровню взаимодействия от низкого. Но введя список требований (интерфейс), которым должен соответствовать низкий уровень мы меняем это отношение: теперь всё зависит от абстракций (интерфейсов), а не деталей реализации друг друга.

Чаще всего, когда мы пишем какую то инструкцию (ведь программа - это инструкция), мы вносим в нее определенные роли вещей, а не то, как они должны это делать. Нам все равно, как сковородка жарит и как работает двигатель. Нам главное, что автомобиль ездит. Нас интересуют характеристики, что он должен уметь! А не то, как он внутри устроен и как он это делает. Если в инструкции мы завяжемся на конкретную имплементацию - то если кто то захочет поменять реализацию, то он не сможет использовать инструкцию (так как мы описали и как все устроено). Чаще всего это значит опираться на интерфейсы, а не на конкретные классы

Пример
```java
// Не правильно
class Main {
    static class ConsoleLogger {
        void printInConsole(String msg) {
            System.out.println(msg);
        }
    }

    static void main(String[] args) {
        // тут мы завязываемся на ConsoleLogger
        // и мы не можем использовать что то, что не подходит под
        // класс ConsoleLogger
        ConsoleLogger logger = new ConsoleLogger();  
        logger.printInConsole("Hello!");  // обязаны вызывать printInConsole
        // а не просто метод "залогируй"
    }
}

// Правильно
public interface Logger {
    // создаем отдельный интерфейс Логгер, который описывает идеи логирования сообщений
    void log(String msg);
}
static class ConsoleLogger implements Logger {
    // КОнсольный логгер просто имплементирует этот функционал
    void printInConsole(String msg) {
        System.out.println(msg);
    }

    @Override
    public void log(String msg) {
        printInConsole(msg);
    }
 }

public static void main(String[] args) {
    Logger logger = new ConsoleLogger();
    logger.log("Hello!");
}
```
Теперь вместо того, чтобы нашей логике в main зависеть от деталей реализации класса логгирования (в данном случае логгирования в консоль), наша логика тут будет зависеть только от абстракции процесса логгирования (от интерфейса Logger), как и сам консольный логгер будет зависеть от этой абстракции (т.к. он реализует этот интерфейс). Сделав так, нам больше не надо беспокоиться о многих деталях реализации логгера, а поменять один логгер на другой (например, на отправку лога по почте) будет стоить нам лишь указания нужного конструктора, ничего другого нам менять не придётся.