# Порождающие, структурные и поведенческие шаблоны

Шаблоны проектирования – стандартные подходы к решению стандартных проблем.

До сегодняшнего момента мы привыкли изучать синтаксис языка, то есть определенные правила, по которым джава нас в принципе поймет. Но, как и в русском, знание падежей не делает нас хорошим писателем. Шаблоны проектирования как раз относятся к качеству кода. Это стандартный набор приемов проектирования нашего кода.

## Виды шаблонов проектирования

Есть разные виды шаблонов проектирования, они касаются того, про что этот набор приемов:
- Порождающие шаблоны - Как правильнее подходить к созданию объектов под разные обстоятельства их дальнейшего использования
- Структурные шаблоны - Как правильнее продумывать и совмещать структуры разных объектов, проектировать иерархию классов и интерфейсов (как расположены данные внутри объекта, какие интерфейсы он реализует)
- Поведенческие шаблоны - Как правильнее подбирать возможности ваших объектов для удобного взаимодействия с ними

## Порождающие шаблоны (Builder, Singleton)

### Шаблон Builder (Строитель)

Самый популярный порождающий шаблон проектирования.
- Для эксплуатации дома не нужно знать всё про его строительство
- Знания про особенности строительства можно вынести за пределы понятия «дом» и предоставить отдельной сущности – строителю
- В ходе строительства мы общаемся со строителем, сообщаем необходимую информацию. В результате, запрашиваем у него готовый объект

Используя шаблон Builder, мы выносим весь процесс строительства в отдельную тему, отделяя его от использования готового дома. Некоторые объекты достаточно сложно конструируются, не просто через `new`.

Создавать напрямую объект сложно или неэффективно
```java
public static void main(String[] args) {
    String[] parts = { "Первая часть", "Вторая часть", "Третья часть" };
    
    String joined = "";
    for (String part : parts) {
        joined += part;  // это очень неээффективно! Каждый раз создается новая строка, в нее копируется все существующее
    }
    System.out.println(joined);
}
```
Воспользуемся вспомогательным объектом, единственная цель которого взять на себя процесс создания целевого объекта
```java
public static void main(String[] args) {
    String[] parts = { "Первая часть", "Вторая часть", "Третья часть" };

    // создаем объект строителя строки
    StringBuilder joinedBuilder = new StringBuilder();
    // пробегаемся по массиву
    for (String part : parts) {
        joinedBuilder.append(part);
    }
    String joined = joinedBuilder.toString();
}
```
Даже само название Builder говорит о том, что это временный объект, используемый для того, чтобы получить целевой объект.

### Шаблон Singleton (Одиночка)

Некоторые объекты существуют в единственном экземпляре для своего вида.

Самолётов, как и объектов в программе, может быть много. Но все они при полётах взаимодействуют с небом. Сколько объектов неба правильнее создать? Только одно небо – общее для всех
- Самолёты - много штук
- Небо - одно, общее.  
Небо подходит под шаблон Singleton, в отличие от самолётов

Почему мы не можем просто создать объект и дальше передавать его, куда надо? Программа может быть большой и нам всегда придется его передавать отдельным параметром. Это очень неудобно и иногда невозможно (если нам код заходит в библиотечный и обратно в наш). Поэтому цель - создать такой класс, у которого будет только 1 объект в работающей программе.

Объект этого класса один на всю программу. 
- Скрываем конструктор, так как он всегда создаёт новый объект. 
- Вместо конструктора даём статистический метод. 
- Когда нужен объект – вызываем метод get()

Предположим что у нас есть класс А. Первым делом мы делаем **приватным** конструктор. Мы никак не можем написать конструктор так, что если он успешно завершился - не будет создан новый объект. Поэтому мы вместо приватного конструктора даем метод, который мы уже можем  продумать так, чтобы он всегда возвращал один однажду созданный объект, это напоминает немного инкапсуляцию, когда мы скрываем поля за модификатором и вместо этого даем геттеры и сеттеры. Потому что методы гораздо более гибкие. Поэтому мы даем статический метод гет, его суть в том, чтобы он всегда возвращал один и тот же объект. Поэтому мы создаем поле `instance`, в котором изначально лежит налл и, когда вызывается метод гет, мы проверяем - если там налл, значит, нас еще не просили создать объекта, тогда мы просто создаем объект. Иначе - просто возвращаем то, что там лежит.
```java
public class A {
    private static A instance = null;

    private long start; // другие поля и методы

    private A() { /* ... */ }  // ленивая реализация синглтона 

    public static A get() {
        if (instance == null) instance = new A();
    return instance;
    }
}
```
Это ленивая реализация синглтона - когда мы максимально откладываем выполнение какого то действия перед тем, как начинаем его выполнять.

Есть реализация синглтона на енаме (старый вопрос с собесов) - можем создать енам и указать одно значение. Тогда сама джава позаботится о том, чтобы это был единственный объект. Минус тут в том, что енамы более ограниченны, чем классы, мы не может использовать всю мощь ооп.

Шаблон Singleton на enum 
- Java сама следит за тем, чтобы объект этого типа был единственным
- Потокобезопасна «из коробки» (подробнее про многопоточность на следующем модуле, многопоточность - это когда в одной программе куча джава программ работают и они между собой делят одну и ту же память)
- Enum менее функциональны, чем классы
```java
public enum A {
    INSTANCE;
    private long start; // другие поля и методы
    private A() { /* ... */ }
}
```

## Структурные шаблоны (Adapter, Decorator) (10 30)

Касаются структуры объектов

### Шаблон Adapter (Адаптер)

Адаптер == переходник

Окружающие объекты, как и объекты в программировании, взаимодействуют между собой. Например, розетка и устройство, которое мы хотим зарядить Но что делать, когда объекты имеют несовместимые интерфейсы? Как зарядить телефон, если его нельзя воткнуть в розетку напрямую? Для решения этой проблемы мы используем шаблон Adapter, совмещая несовместимые интерфейсы взаимодействия с помощью специального переходника

Заставляем работать вместе объекты, которые подходят друг другу логически, но несовместимы из-за типизации
```java
public interface IStorage {
    // интерфейс, который описывает хранилище строк
    void append(String line);  // добавляет новую строку
}

public class Logger {
    // у нас есть логгер. Он говорит - дай ка мне хранилище строк, куда я буду логировать сообщения.
    private final IStorage storage;
    public Logger(IStorage storage) {
        this.storage = storage;
    }
    public void log(String msg) {
        // создает строку из текущей даты и самого сообщения и кладет в хранилище
        storage.append(LocalDateTime.now() + "#" + msg);
    }
}
// но! АррайЛист мы не сможем передаеть, поскольку он не имплементирует никакого IStorage, они структурно не подходят

public class ListStorageAdapter implements IStorage {
    // создадим адаптер, который будет заявлять, что является IStorage
    private final List<String> list;
    public ListStorageAdapter(List<String> list) {
        // принимает на вход список
        this.list = list;
    }

    @Override
    public void append(String line) {
        list.add(line);
    }
}
```
Теперь мы можем создать адаптер и уже его воткнуть в логгер. Каждый раз, когда логгер будет просить что то добавить - адаптер будет вызывать метод эдд у этого списка. Таким образом логгер начнет работать с этим списком.

ТУТ МЫ СОВСЕМ НЕ ИСПОЛЬЗОВАЛИ НАСЛЕДОВАНИЕ! Это было бы не совсем то, что мы хотели. Наследование во многом переоценено. Наследоваться лучше только тогда, когда класс специально создан для наследования, иначе можно нахватать разных проблем. Здесь мы обошлись тем что вместо наследования просто взяли и обернули список, который нам передается. По сути, в программировании это называется композицией.

### Шаблон Decorator (Декоратор) 13:50

- Люди склонны классифицировать вещи по типам и свойствам
- Примеры типов: экстраверт и интроверт. Их свойства: радостный и печальный
- Свойства радостный и печальный могут применяться к любым типам, например, мужчина и женщина. Эти свойства независимы от типа
- Независимые свойства позволяют избежать создания множества ненужных отдельных типов: печальный интроверт, печальный мужчина, печальная женщина
- Мы просто выносим свойство «печальный» как отдельную характеристику, которой можно дополнить любой другой тип
- Таким образом, мы можем наделить тип «мужчина» разными независимыми свойствами: печальный, строгий, высокий, ловкий.  
По такому же принципу мы работаем с шаблоном Decorator, считая, что некоторые функции независимо друг от друга дополняют уже существующие типы, при этом не создавая новых типов, а наделяя уже существующие объекты конкретными характеристиками

Допустим, у нас в какой то библиотеке есть 10 видов айстораджей. Придумаем новый функционал - он заключается в том, что если передается строка, в которой есть `Error` - то она должна сохраниться с заглавными буквами. Первая мысль - для каждого из 10 айстораджей сделать наследника с определенным методом `append`, который будет проверять на наличие этого слова. Но так мы повтораяем очень много кода. Так что логичнее использовать декоратор. Грубо говоря, это переходник, но который решает не проблему совместимости 2 объектов, а включение которого добавляет новый функционал. То есть на этот пример мы можем создать 1 новый класс ErrorCapsDecorator
```java
public class ErrorCapsDecorator implements IStorage {
    private final IStorage storage;
    public ErrorCapsDecorator(IStorage storage) {
        // передай нам сторадж, я его просто сохраню
        this.storage = storage;
    }

    @Override
    public void append(String line) {
        // но когда меня попросят append - я скажу что если там (в сообщении) есть 
        // error, то я его сохраню в toUpperCase, иначе сохраню как есть
        storage.append(line.contains("error") ? line.toUpperCase() : line);
    }
}

// так мы изменили поведение объекта, не прибегая к наследованию!
public static void main(String[] args) {
    IStorage storage = ...;
    IStorage withErrorCaps = new ErrorCapsDecorator(storage);
}
```
- Расширяем функционал через оборачивание вместо наследования. 
- Вне зависимости от количества storage добавление новой функциональности потребовало один класс. 
- Декораторы можно комбинировать, но не всегда. Так, если новая функциональность заключается в наличии нового метода - останется только последний (самая внешняя обертка). В питоне декоричрование важнее, ведь там нет строгой типизации. Поэтому там декораторы встроены в сам язык. В джаве такого нет, не хватает свободы.