## Особенности ссылочных типов данных

Тип данных String используется для того чтобы хранить текст. Это переменная ссылочного типа данных, мы это определили по первой букве (обычно ссылочные типы данных начинаются либо с большой буквы, либо у них в названии типа есть различные квадратные скобки). Если мы говорим про примитивные типы данных, то `int x = 10;` будет означать что джава выделит нам ячейку памяти размером в 32 бита и туда запишет число 10 (превратит число 10 в последовательность 0 и 1, которые туда и запишет). При этом мы знаем, что размеры ячейки наприямую диктуют диапазон допустимых значений. В типе данных String может быть любой текст - он может состоять из 0 символов, 1, нескольких или сотни миллионов символов. Поэтому ссылочные типы данных работают по другому, чем примитивные - мы не знаем, какое количество ячеек памяти нам нужно выделять. Вторая проблемы ссылочных типов данных - программирование это в основном перекидывание данных из одного места в другое. К примеру, мы можем создать статический метод, который принимает строку и делает что то с этой строкой. Если мы вызовем нашу команду `f(s);` - то по сути мы просто попросим джаву создать в момент вызова параметр name и скопировать туда то значение, которое было в круглых скобках. Однако если у нас строка очень большая - то у нас это копирование может занимать много времени. В реальности же метод может делать какую то простую операцию.
```java
public class Lecture05 {
    public static void main(String[] args) {
        int x = 10;
        String s = "Hello";
        f(s);
    }

    public static void f(String name) {
        //   
    }
}
```
Эти 2 проблемы решаются следующим приемом. Джава не превращает Hello в 0 и 1 и записывать напрямую в ячейку s. джава пойдет в специальную область памяти, которая называется куча. Там она найдет свободное место и разместит этот текст. Потом адрес этого места она запишет в переменную. То есть в переменной у нас будет храниться не текст, а адрес в куче. Так решается первая проблема (нам достаточно выделить ячейку, в которой будет храниться только адрес нашего объекта). Вторая проблема также решается  - при вызове функции мы копируем не целиком объект, а только адрес, где он находится. В этом самое главное отличие ссылочных типов данных от примитивных.

Операции над примитивными типами данных чаще всего совершаются с помощью значков (+, - и тд), тк чаще всего это обычные числа. В случае с ссылочными типами данных - не для всех операций мы можем подобрать значки, поэтому используется другой подход. К ссылочным типам данных есть очень много методов.  
Еще одно отличие - это создание ссылочных типов данных. String тут немного вынесем за скобки, тк это особых тип данных. Создадим сканнер и сравним создание значения примитивного типа данных и ссылочного. В общем случае создание значения ссылочного типа данных выглядит как `new НазваниеТипаЗначениеКоторогоМыХотимСоздать(ДополнительнаяИнформация.котораяНужнаЭтомуТипуДляСозданияЗначения)`. В примере ниже - сканнеру нужна информация, откуда он будет сканировать значения (с консоли, с интернета и тд).
```java
import java.util.Scanner;

public class Lecture05 {
    public static void main(String[] args) throws Exception {
        int x = 10;
        x += 10;
        x--;

        String s = "Hello";
        s.contentEquals(s);
        // ...
        Scanner scanner = new Scanner(System.in);
    }
}
```
Ссылочные типы данных обычно называются объектами.

Еще раз разберем на примере ArrayList. Это встроенный тип данных в джаве, который олицетворяет собой список. Перед использованием нужно заимпортировать (лежит в java.utils)
```java
import java.util.ArrayList;

public class Lecture05 {
    public static void main(String[] args) {
        ArrayList list = new ArrayList();
        // джава создала этот список в куче и записала адрес, где он лежит
        System.out.println(list);
        // если выведем список на экран - увидим что он пуст, []

        // jпложим в него что нибудь
        list.add("Anya");
        list.add("Petya");
        list.add("Olya");
        System.out.println(list);

        ArrayList list2 = list;
        list2.remove("Olya");
        System.out.println(list);
        System.out.println(list2);
    }
}
```
При изменении одного объекта в куче изменятся все объекты, ссылающиеся на эти ячейки! При этом если заполнить новый объект такими же значениями и сравнить объекты - джава выведет что они не равны, тк они будут ссылаться на разные ячейки в куче. (для примитивных типов данных будут храниться и сравниваться сами значения, для ссылочных - адреса ячеейк). Ссылочные типы данных нужно сравнивать через `list.equals(list2);`
```java
import java.util.ArrayList;

public class Lecture05 {
    public static void main(String[] args) {
        ArrayList list = new ArrayList();
        // джава создала этот список в куче и записала адрес, где он лежит
        System.out.println(list);
        // если выведем список на экран - увидим что он пуст, []

        // jпложим в него что нибудь
        list.add("Anya");
        list.add("Petya");
        list.add("Olya");

        ArrayList list2 = new ArrayList();
        list2.add("Anya");
        list2.add("Petya");
        list2.add("Olya");

        System.out.println(list == list2);
        System.out.println(list.equals(list2));
        System.out.println(list);
        System.out.println(list2);
    }
}
```
в любую переменную ссылочного типа данных мы можем передать специальное значение `null`. Это вполне себе валидный адрес (мы можем передать его в любую ячейку), единственное исключение - что по нему ходить нельзя. Это используется когда мы хотим временно заполнить ячейку, чтобы джава все спокойно скомпилировала, а потом заполнить ячейку нормальным адресом. Мы даем временный адрес, зная, что по нему ходить нельзя. Если попытаемся по нему пройти - будет ошибка
```
ArrayList list2 = null;
list2.add("A);  // упадет с ошибкой
```

## Тип данных String

Хоть это и ссылочный тип данных, но он особый в джаве (тк часто используется). Например, не требуется new. Еще не всегда требуется писать все команды через точку (как методы) - можно и конкатенировать через +.
```java
public class Lecture05 {
    public static void main(String[] args) {
        // String s = "Hello world";
        String s = "Hello " + "world";
        System.out.println(s);
    }
}
```
На этом особенность заканчивается - перейдем к обычным методам
```java
public class Lecture05 {
    public static void main(String[] args) {
        String s = "Hello world";
        System.out.println(s);

        System.out.println(s.replace('l', '@'));
        System.out.println(s);  // будет исходный текст - объекты в Java (текст) - неизменяемые
        // все операции над стрингом - создают клона себя с нужной мутацией
        // мы изменения никуда не сохранили, мы просто вывели его на экран через println
        s = s.replace('l', '@');  // так бы значение переменной поменялось, 
        // но при этом в куче бы остался старый текст по старому адресу, у нового - новый адрес
    }
}
```
При `System.out.println(s.replace('l', '@'));` переменная s не поменяется! Наши изменения никуда не сохранятся, а пойдут в вывод. Все операции над стрингом - создают клона себя с нужной мутацией. Чтобы поменять значение переменной, нужно его присвоить `s = s.replace('l', '@');`, но при этом в куче бы остался старый текст по старому адресу, у нового - новый адрес. За ячейками со старыми значениями, которые лежат и тратят нашу память, следит джава (за тем чтобы мы всегда хранили для наших объектов адреса). Если мы теряем где то адрес нашего объекта - джава резонно считает что объект нам больше не нужен и подчищает память.

Еще методы
- `s.contains("smth");`
- `s.startsWith("smth");`
- `s.indexOf(" ");`
- `s.`

Типичная задача - собрать стринг из разных кусков. Если мы будем по цепочке присоединять значения - то у нас на каждой итерации будет выполняться копирование старого текста. Чтобы избежать этого, у нас есть специальный тип для того чтобы собирать строку по частям - `StringBuilder`
```java
public class Lecture05 {
    public static void main(String[] args) {
        String s = "";
        s = s + "hello";
        s = s + " ";
        s = s + "world";
        System.out.println(s);

        StringBuilder sb = new StringBuilder();
        sb.append("hello");
        sb.append(" ");
        sb.append("world");
        System.out.println(sb.toString());
    }
}
```

Посмотрим на практике выгоду от такого метода
```java
public class Lecture05 {
    public static void main(String[] args) {
        final int N = 1_000_000;  // количество итераций

        // будем собирать текст из миллиона символов "!""
        System.out.println("Start");
        String s = "";
        // StringBuilder sb = new StringBuilder();

        for (int i = 0; i < N; i++) {
            // вывод прогресса на экран
            if (i % (N / 100) == 0) System.out.println((i / (N / 100)) + "%...");
            // sb.append('!');
            s += '!';
        }
        // System.out.println(sb.toString());
        System.out.println("End");
        System.out.println("Generated string length: " + s.length());
    }
}
```
final - джава будет следить чтобы мы не меняли значение этой переменной , константа

После 50% начнется сильное замедление! Сравним с аппендом - отработает почти моментально. Поэтому StringBuilder и используется для того чтобы собирать текст по частям.

## Тип данных Enum

Решим такую задачу - у нас будут в переменной храниться 2 недели, а мы будет отвечать на вопрос, выходной сегодня день или нет.
```java
public class Lecture05 {
    public static void main(String[] args) {
        int day = 6;
        System.out.println(isDayOff(day));
    }

    public static boolean isDayOff(int day) {
        if (day == 6 || day == 7) {
            return true;
        } else {
            return false;
        }
        // return day == 6 || day == 7;  // более короткая запись
    }
}
```
Какие проблемы у этой программы? Для нас не  очень понятно, какой номер у какого дня недели. Также в зарубежных календарях очень часто неделя начинается воскресения. Стандартное решение этой проблемы - заведем ячейки, единственное назначение которых - хранить номера дней недели, когда захотим использовать этот номер - будет просто обращаться к ячейке по имени.
```java
public class Lecture05 {
    public static final int MON = 1;
    public static final int TUE = 2;
    public static final int WED = 3;
    public static final int THU = 4;
    public static final int FRI = 5;
    public static final int SAT = 6;
    public static final int SUN = 7;

    public static void main(String[] args) {
        int day = SAT;
        System.out.println(isDayOff(day));
    }

    public static boolean isDayOff(int day) {
        if (day == SAT || day == SUN) {
            return true;
        } else {
            return false;
        }
        // return day == SAT || day == SUN;  // более короткая запись
    }
}
```
Но так мы теряем безопасность типов - ведь для джавы все, что она знает про переменную day - это что она типа инт. Она позволит присваивать сюда любые значения, которые подходят под диапазон (например, -50). Поэтому мы можем создать специальный тип данных, который будет означать день. Этот тип данных будет из специального ссылочного типа. Для того чтобы создать новый тип данных Day мы создадим отдельный джава файл (обычно так и принято - на каждый новый тип данных отдельный джава файл). В идее это src -> new -> new Java file -> Enum . 
```java
public enum Day {
    // перечислим здесь названия значений, которые мы хотим иметь
    // Джава сама создаст значения для этих типов данных
    MON, TUE, WED, THU, FRI, SAT, SUN;
}
```
Как теперь видоизменится наша программа:
```java
public class Lecture05 {
    public static void main(String[] args) {
        Day day = Day.SAT;
        System.out.println(isDayOff(day));
    }

    public static boolean isDayOff(Day day) {
        if (day == Day.SAT || day == Day.SUN) {
            return true;
        } else {
            return false;
        }
        // return day == Day.SAT || day == Day.SUN;  // более короткая запись
    }
}
```
Сравнивать значение енамов мы можем как через .equals, так и через ==. Дело в том что у енама фиксированное количество значений, которые он может иметь. Когда мы перечислили в енаме субботу - он создал одну-единственную субботу, у нас не бывает 2 суббот, которые мы можем иметь. У нас невозможен дубляж значений енама, все переменные будут иметь адрес именно этого значения.

## Преза

Ссылочные типы данных - В специальной области памяти — heap — создаётся ячейка. Значение записывается в ячейку в виде бинарного кода. А в переменную идёт ссылка на адрес ячейки в heap

Пример создания ссылки на объект `Object = example1 = null;`
- Object и String — тип создаваемой ссылки
- example1 и example2 — имена ссылок, по которым мы сможем дальше обращаться к этим объектам в программе
- null — ключевое слово в Java, обозначающее отсутствие, то есть фактически example1 и example2 — это ссылки на несуществующие объекты  
На основе этих файлов с помощью специальных конструкторов создаются объекты. Каждый класс является по умолчанию наследником класса Object. Исключая примитивные типы, всё в Java является объектом

Каждый примитивный тип имеет аналог ссылочного типа. Они называются «классы-оболочки» (wrappers)
- short — Short
- byte — Byte
- int — Integer
- long — Long
- float — Float
- double — Double
- char — Character
- boolean — Boolean  
Такие классы нужны для расширения функционала примитивных типов, например, для преобразования строки в число: `Integer.parseInt("1901");`

Методы класса Object
- void notify() — возобновляет выполнение потока, которого ожидает вызывающий объект
- void notifyAll() — возобновляет выполнение всех потоков, которых ожидает вызывающий объект
- String toString() — возвращает строку, описывающую объект
- void wait() — бесконечно долгое время ожидает другой поток выполнения
- void wait(long millis) — определённое время ожидает другой поток выполнения
- void wait(long millis, int nanos) — определённое время ожидает другой поток выполнения