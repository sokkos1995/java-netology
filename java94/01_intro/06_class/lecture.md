# Структура класса

Основы ООП, классы как шаблоны для объектов, как мы можем проектировать память для наших объектов.

## Поля класса

Создадим новый джава класс. Мы можем использовать этот класс для того чтобы создать новый тип данных в джаве. Опишем в нем то, что мы хотим чтобы каждый объект знал о себе
```java
public class Singer {
    public String name;  // не public!
    public int age;
    public int rating;
}
```
Этого достаточно чтобы каждый раз когда джава будет создавать новый объект - она будет внутри него создавать 3 ячейки: имя, возраст и рейтинг. Теперь при создании экземпляра класса мы сможем задать ему данные атрибуты
```java
public class Lecture06 {    
    public static void main(String[] args) {
        Singer singer = new Singer();
        singer.name = "Petya";
        singer.age = 27;
        singer.rating = 10;
    }
}
```
В итоге вся информация у нас упаковалась внутрь ячеек, которые находятся внутри объекта, и уже адрес на этот объект мы сохранили в переменной singer. Теперь чтобы передать информацию о певце куда то, нам достаточно будет передать ячейку типа Singer. Ячейки имя, возраст и рейтинг будут называться полями. Рассмотрим отличия этих полей от статических полей, для этого создадим класс со статическим полей
```java
public class A {
    public static int x;
}
```
Для того чтобы обратиться к статическому полю, достаточно указать название класса, точку и название поля и присвоить туда что то. Обратите внимание, что при обращении к нестатическому полю ия класса не указывается! Мы указываем переменную, внутри которой находится адрес объекта, у которого есть эта переменная, именно это поле. 
```java
public class Lecture06 {    
    public static void main(String[] args) {
        Singer singer = new Singer();
        singer.name = "Petya";
        singer.age = 27;
        singer.rating = 10;

        A.x = 5;
    }
}
```
Отличие философское - когда мы объявляем статическое поле, у нас создается одна ячейка на программу и к ней мы обращаемя через имя класса, указывая джаве, где ее искать. У нас одна ячейа с именем х, находящаяся в классе А. Когда же я объявляю переменную name в классе Singer без иджентификатора static, это означает, что эта переменная будет жить внутри каждого объекта данного типа данных. До того как мы создадим первого певца у нас не будет ни одной переменной типа name (точнее, поля). Поэтому бессмысленно было бы обращаться к этому полю через имя класси (писать `Singer.name = "Petya";`), ведь джаве будет непонятно, к какой ячейке с именем name мы обращаемся, потому что у каждого объекта типа Singer она будет своей. Джава от нас потребует указать конкретный объект, с которым мы имеем дело. В итоге мы видим большую разницу между статическими и не статическими полями. Статические - аналог глобальных переменных, не-статические - аналог внутренних переменных внутри каждого объекта этого типа данных.  
С помощью нестатических полей мы можем проектировать память объекта, а именно какие данные они должны хранить у себя внутри.

## Методы класса

Мы пока что не спроектировали никакие действия нашего певца. Для этого мы создаем метод в классе. Обратите внимание на то, что здесь не используется слово `static`, поскольку метод не является статическим. Пишем `public {возвращаемый тип} {имя метода} ({Параметры})`
```java
public class Singer {
    public String name;
    public int age;
    public int rating;

    public void sing(String verse) {
        System.out.println("Я, " + name + ", пою тебе: " + verse);
    }
}
```
Обратите внимание, что мы обращаемся к статическим полям без точки! `System.out.println("Я, " + name + ", ` , а не `Singer.name`, без указания объекта, с которым имеем дело. Мы можем не указывать объект, поскольку мы указали этот объект при вызове команды. Здесь будут вызываться не-статические поля именно того объекта, на котором мы вызвали команду.

При этом мы вызываем этот метод указывая объект этого певца! Это не является статическим методом, поэтому мы не указываем класс, в котором он обозначен. В случае статических методов было бы достаточно указать джаве класс где искать этот метод. Здесь же мы указываем просто название переменной, где хранится адрес этого объекта
```java
public class Main {
    public static void main(String[] args) {
        Singer singer = new Singer();
        singer.name = "Petya";
        singer.age = 8;
        singer.rating = 3;
        singer.sing("Good morning!");
        System.out.println(singer);
    }
}
```

Создадим еще какую нибудь команду для певца.
```java
public class Singer {
    public String name;
    public int age;
    public int rating;

    public void sing(String verse) {
        System.out.println("Я, " + name + ", пою тебе: " + verse);
    }

    public boolean isTooYoung() {
        if (age < 10) {
            return true;
        } else {
            return false;
        }
    }

    public String toString() {
        return "[" + rating + "] " + name + " (" + age + " лет)";
    }
}
```
Разберем еще одну полезную команду - `toString()`. Дело в том что когда мы просим вывести какой то объект на экран, то выведется следующее:
```java
System.out.println(singer);
// Singer@2a3046da
```
Как джава решает, в каком виде вывести объект на экран? На самом деле джава не хочет разбираться, что там происходит внутри объекта, как он устроен. Джава просто вызывает встроенную команду `toString()`, эта команда ничего не принимает параметрами, но возвращает текст в ответ, именно он и выводится на экран
```java
public String toString() {
    return "[" + rating + "] " + name + " (" + age + " лет)";
}
// [3] Petya (8 лет)
```
Мы можем создавать мноого объектов этого типа, например, создать еще одного певца
```java
public class Main {
    public static void main(String[] args) {
        Singer singer = new Singer();
        singer.name = "Petya";
        singer.age = 8;
        singer.rating = 3;
        singer.sing("Good morning!");
        System.out.println(singer);

        Singer singer2 = new Singer();
        singer2.name = "Anya";
        singer2.age = 15;
        singer2.rating = 4;
        System.out.println(singer2);
    }
}
```
Имена певцов - различные ячейки и будут находиться в разных объектах! Именно поэтому при обращении к нестатическому полю мы вынуждены указывать имеено объект, с которым имеем дело. Так же как и при вызове нестатического метода мы вынуждены указать объект, у которого мы его вызываем. Потому что по определению нестатический метод - это та команда, которую должен выполнять объект, потому что он использует собственные данные.

## Конструкторы

Как нам провильно инициализировать объекты, то есть готовить их изначальное правильное и корректное состояние и какие инструменты нам джава для этого дает.

Сейчас нам для того чтобы создать новый объект певца, достаточно сделать `Singer singer = new Singer();`. Но при этом у нас объект недозаполненный, дело в том что когда мы не присваиваем никакие значения в поля - то туда присваиваются значения по умолчанию (0, False, для ссылочных данных это всегда будет налл). Мы можем указать в круглых скобках всю ту инфу, которая нужна для создания объекта, это и будет конструктор. Конструктор похож на обычный метод, но у него есть некоторые отличительные особенности. Например, у него не указываются возвращаемые значения, также он называется так, как называется класс. По умолчанию джава создаем конструктор (если мы не создаем его сами), не передавая туда при этом ничего 
```java
public class Singer {
    public String name;
    public int age;
    public int rating;

    public Singer() {

    }
}
```
Конструктор - это, по сути, метод. У него есть параметры и у него есть кусок кода, который будет выполняться при вызове этого метода. Но это особенный метод - мы не можем вызвать его сами напрямую. 

Расмотрим поподробней, что происходит, когда мы пишем `Singer singer = new Singer();`. Когда мы просим джаву создать новое значение типа данных Singer, джава идет в кучу, видит, что ей нужно будет хранить имя, возраст и рейтинг (`public String name;` и так далее в классе Singer), соответственно, она ищет подходящее место в этой куче и создает там внутри ячейки для этих значений. Затем она наделяет объект определенными командами, которые он может выполнять. В конце джава просто обязуется вызвать конструктор. Если джава сама создала конструктор - то он по сути пустой и никакого действия не происходит. Но если мы его сами добавим - то можем прописать там дополнительные действия. Это происходит до того, как мы отдали адрес объекта для сохранения в переменную.
```java
public class Singer {
    public String name;
    public int age;
    public int rating;

    public Singer() {
        System.out.println("Hello!");
    }
}
```
```java
public class Main {
    public static void main(String[] args) {
        Singer singer = new Singer();
    }
}
```
В конструкторе мы можем сами делать что угодно - открывать файлы, заполнять значения и тд. Конструктор — это специальный метод класса, который ничего не возвращает, но описывает, каким образом должен быть собран/инициализирован класс. Например, какие должны быть значения полей у только что созданного объекта

Мы можем передавать параметры в конструктор.
```java
public class Singer {
    public static int maxRating = 0;

    public String name;
    public int age;
    public int rating;

    public Singer(String name, int age, int rating) {
        this.name = name;
        this.age = age;
        this.rating = rating;
    }
}
```
```java
public class Main {
    public static void main(String[] args) {
        Singer singer = new Singer("Petya", 8);
        System.out.println(singer);
    }
}
```
this использовать обязательно, тк у нас совпадают имя параметра и имя поля. А джава руководствуется логикой "что ближе - то мое". this - это встроенная переменная, логически можно считать что в this находится адрес нас самих, адрес того объекта, у которого вызвали метод или который прохходит стадию конструктора.

Джава нас не ограничивает одним конструктором, мы можем создавать и несколько конструкторов. Например, создадим несколько конструкторов - с 2 аргументами и с 3. Вызван при этом будет один конструктор - которому подходит количество, порядок и типы параметров. Можем и вызывать конструктор из другого конструктора!
```java
public class Singer {
    public String name;
    public int age;
    public int rating;

    public Singer(String name, int age, int rating) {
        this.name = name;
        this.age = age;
        this.rating = rating;
    }

    public Singer(String name, int age) {
        this(name, age, 3);  // это будет вызов конструктора!
//        this.name = name;
//        this.age = age;
//        this.rating = 3;
    }
}
```
`this(name, age, 3);` - если обратиться таким образом (как к методу), то это будет вызов конструктора!

Посмотрим, можем ли мы использовать в одном и том же классе статические и нестатические поля. Введем макимальный рейтинг среди всех певцов. Это одна сущность, одно данное, которое существует на протяжении всей программы `public static int maxRating = 0;`
```java
public class Singer {
    public static int maxRating = 0;

    public String name;
    public int age;
    public int rating;

    public Singer(String name, int age, int rating) {
        this.name = name;
        this.age = age;
        this.rating = rating;
        maxRating = Math.max(maxRating, rating);
    }

    public Singer(String name, int age) {
        this(name, age, 3);
    }

    public void sing(String verse) {
        System.out.println("Я, " + name + ", пою тебе: " + verse);
    }

    public boolean isTooYoung() {
        if (age < 10) {
            return true;
        } else {
            return false;
        }
    }

    public String toString() {
        return "[" + rating + "] " + name + " (" + age + " лет)";
    }
}
```
Теперь у нас в случае, если у нового певца рейтинг будет больше чем у предыдущего - значение максимального рейтинга обновится! `maxRating = Math.max(maxRating, rating);`
```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        System.out.println("Макс рейтинг: " + Singer.maxRating);

        Singer singer = new Singer("Petya", 8);
        System.out.println(singer);
        System.out.println("Макс рейтинг: " + Singer.maxRating);

        Singer singer2 = new Singer("Anya", 15, 4);
        System.out.println(singer2);
        System.out.println("Макс рейтинг: " + Singer.maxRating);
    }
}
```
Output
```
Макс рейтинг: 0
[3] Petya (8 лет)
Макс рейтинг: 3
[4] Anya (15 лет)
Макс рейтинг: 4
```
Singer.maxRating - так как это у нас статическое поле, мы обращаемся через имя класса.

Типом данных для наших полей могут быть любые типы. Мы спокойно можем создать еще один класс, назвать его Album. 
```java
public class Album {
    public String title;
    public int releaseYear;
    public Singer singer;

    public Album(String title, int releaseYear, Singer singer) {
        this.title = title;
        this.releaseYear = releaseYear;
        this.singer = singer;
    }
}
```
```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        System.out.println("Макс рейтинг: " + Singer.maxRating);

        Singer singer = new Singer("Petya", 8);
        System.out.println(singer);
        System.out.println("Макс рейтинг: " + Singer.maxRating);

        Singer singer2 = new Singer("Anya", 15, 4);
        System.out.println(singer2);
        System.out.println("Макс рейтинг: " + Singer.maxRating);

        Album album = new Album("Ой весна", 2021, singer2);
    }
}
```
Может показаться что мы целиком в альбоме храним целиком певца. Однако если мы вспомним, что это все ссылочные типы данных - мы поймем, что у нас в поле singer хранится только адрес нашего певца, а не целиком певец!

Чтобы создать в Java новый объект из класса, используется оператор new. При его вызове в памяти JVM (компьютера/телефона) выделяется область для хранения данных об этом объекте
