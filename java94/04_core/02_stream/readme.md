# Stream API. Потоки, повторные вызовы, основные методы

## Stream API

Начиная с JDK 8 в Java появился новый API — Stream API. Его задача — упростить работу с наборами данных (с коллекциями), в частности, упростить операции фильтрации, сортировки, модификации и другие манипуляции с данными. Основная функциональность Steam API сосредоточена в пакете `java.util.stream`

Ключевым понятием стрим апи является стрим. Это канал передачи данных из источника данных. В качестве источника могут выступать файлы, массивы и коллекции. Его жизненный цикл состоит из 3 стадий
- создание стрима
- применение к стриму промежуточных операций
- применение к стриму завершающей операции для получения результата

Стрим опирается и берет данные из источника, им может быть коллекция/массив/метод. Пример создания стрима
```java
List<String> list = new ArrayList<>();

list.add("One");
list.add("Two");
list.add("Three");

Stream stream = list.stream();
```
Кроме объектных стримов, есть и специальные стримы 
- IntStream — для int
- LongStream — для long
- DoubleStream — для double  
Для boolean, byte, short и char специальных стримов нет. Вместо них можно использовать IntStream, а затем приводить к нужному типу. Для Float тоже придётся воспользоваться DoubleStream. Примитивные стримы полезны, так как не нужно тратить время на боксинг/анбоксинг, к тому же у них есть специальные операторы, упрощающие работу с кодом.

Операции со стримами
- Промежуточные — операции, возвращающие трансформированный стрим. К возвращённому стриму также можно применить промежуточные операции. Примеры: фильтрация, преобразование, сортировка, удаление дубликатов, ограничение и многое другое.
- Терминальные — терминальные операции возвращают конкретный результат, они завершающие (получить результат, уже выведенный этим стримом). К терминальным операциям относят: перебор элементов, поиск, нахождение минимума и максимума, расчёт количества и т. д.

Разберем на примере интстрима. У нас есть коллекция из интов от -5 до 5, мы создаем инстрим и фильтр, в фильтре говорим, что число, поступающее на вход, должно быть больше 0. Затем в методе count мы берем количество таких чисел.
```java
import java.util.stream.IntStream;

public class Main {
    public static void main(String[] args) {
        long count = IntStream.of(-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5)
                .filter(i -> i > 0)
                .count();
        System.out.println(count);
    }
}
```
Говоря о разинце между стримом и коллекцией, промежуточные операции в нашем стриме не изменяют источника данных. Соотстветственно, если у нас коллекция из 10 элементов вступила в стрим, сама коллекция изменена не будет. Еще особенности
- Стримы не хранят элементы. Элементы, используемые в стримах, могут храниться в коллекции либо могут быть напрямую сгенерированы
- Операции со стримами не изменяют источника данных, а лишь возвращают новый стрим с результатами этих операций
- Для стримов характерно отложенное выполнение. Выполнение всех операций со стримом происходит лишь тогда, когда выполняется терминальная операция и возвращается конкретный результат, а не новый стрим

Рассмотри на примере, как с помощью стрим апи мы можем упростить код и выстроитиь более правильную логику (и более понятную для чтения)
```java
import java.util.ArrayList;
import java.util.List;
import java.util.stream.IntStream;

public class Main {
    public static void main(String[] args) {
        int[] input = {50, 60, 70, 80, 90, 100};
        List<Integer> result = new ArrayList<>();
        int count = 0;
        for (int x : input) {
            if (x >= 90) continue;
            x += 10;
            count++;
            if (count > 3) break;
            result.add(x);
        }
        System.out.println(result);
    }
}
```
У нас есть массив из интов. Проходя по массиву, мы отбираем элементы, которые меньше чем 90. Попробуем сделать то же самое с помощью стрим апи
```java
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class Main {
    public static void main(String[] args) {
        int[] input = {50, 60, 70, 80, 90, 100};
        List<Integer> result = IntStream.of(input)
            .filter(x -> x < 90)
            .map(x -> x + 10)
            .limit(3)
            .boxed()
            .collect(Collectors.toList());
        System.out.println(result);
    }
}
```
Посмотрим на примере стринг коллекции, определим слова, состоящие только из 3 букв, приведем к верхнему регистру и выведем в консоль
```java
public class Main {
    public static void main(String[] args) {
        List<String> list = Arrays.asList("My", "Pen", "Is", "Black");

        list.stream()
            .filter(x -> x.length() == 3)
            .map(String::toUpperCase)
            .forEach(System.out::println);
    }
}
```

Как это все работает под капотом
- Метод stream() создаёт экземпляр класса Stream
- Каждая промежуточная операция работает с экземпляром стрима и при этом создаёт новый экземпляр стрима на выходе
- Нельзя дважды использовать один и тот же экземпляр стрима. Он одноразовый
- Терминальная операция не даёт на выходе стрима, но даёт какой-либо результат. В данном примере метод forEach возвращает нам все элементы поочередно

Имейте в виду
- Обработка стримом коллекции не начнётся до тех пор, пока не будет вызван терминальный оператор `list.stream().filter(s -> s > 5); `
- Экземпляр стрима нельзя использовать более одного раза
```java
Stream<String> stream = list.stream();
stream.filter(x-> x.toString().length() == 3).forEach(System.out::println);
stream.forEach(x -> System.out.println(x));
// Exception in thread "main" java.lang.IllegalStateException: stream has already been operated upon or closed
```
- Промежуточных операторов, вызванных на одном стриме, может быть множество, а терминальный оператор — только один
```java
stream.filter(x -> x.toString().length() == 3).
    map(x -> x + " - the length of the letters is three").
    forEach(x -> System.out.println(x));
```

## Промежуточные операции

Промежуточные (нетерминальные) операции Stream API — операции, которые преобразовывают или фильтруют элементы в потоке. Добавляя нетерминальную операцию в стрим, получим новый стрим в качестве результата. Новый стрим будет представлять собой поток элементов, полученных из исходного стрима с применением нетерминальной операции

Какие есть промежуточные операции
- Filter - Метод фильтра принимает Predicate, который вызывается для каждого элемента в стриме:
  - Если элемент должен быть включён в результирующий стрим, Predicate должен вернуть значение true
  - Если элемент не должен быть включён, Predicate должен вернуть false
  - Пример: отфильтровать лист. Вывести в консоль город с названием длиной более 3 символов и с наличием буквы "М"
```java
List<String> list = Arrays.asList("Moscow", "NY", "Tokyo");
list.stream()
    .filter(value -> value.length() >= 3)
    .filter(value -> value.contains("M"))
    .forEach(System.out::println);
```
- Map - Маппинг задаёт функцию преобразования одного объект в другой. Например, в списке строк можно преобразовать элементы в нижний регистр, верхний регистр или в подстроку исходной строки и т. д.
  - Пример: преобразуем список городов в слова заглавными буквами и добавим строку
```java
List<String> list = Arrays.asList("Moscow", "NY", "Tokyo");
list.stream()
    .map(String::toUpperCase)
    .map(value -> value + "<3")
    .forEach(System.out::println);
```
- Метод flatMap отображает один элемент в виде нескольких элементов. Идея состоит в том, что flatMap сплющивает каждый элемент из сложной структуры, состоящей из нескольких внутренних элементов, в плоский стрим, состоящий только из этих внутренних элементов
  - Пример: требуется вывести в консоль количество слов в четверостишии
```java
List<String> list = new ArrayList<>();
list.add("И долго буду тем любезен я народу");
list.add("Что чувства добрые я лирой пробуждал");
list.add("Что в мой жестокий век восславил я Свободу");
list.add("И милость к падшим призывал");

long count = list.stream()
    .flatMap(value -> Arrays.stream(value.split(" ")))
    .count();
System.out.println(count); 
```
- Метод distinct применяется для удаления дубликатов. Метод distinct является нетерминальной операцией, которая возвращает новый стрим, который будет содержать только уникальные элементы из исходного стрима. Любые дубликаты будут исключены
  - Пример: требуется удалить дубликаты из листа
```java
List<String> list = Arrays.asList("Moscow", "NY", "Tokyo", "Moscow");
list = list.stream()
    .distinct()
    .collect(Collectors.toList());
System.out.println(list); 
```
- Метод limit применяется для ограничения количества элементов в стриме. Метод limit возвращает новый стрим, который будет максимально содержать заданное в качестве аргумента количество элементов
  - Пример: требуется вывести в консоль ограниченное число элементов листа
```java
List<String> list = Arrays.asList("Moscow", "NY", "Tokyo");
list = list.stream()
    .limit(2)
    .collect(Collectors.toList());
System.out.println(list); 
```
- Метод sorted применяется для сортировки элементов источника стрима, В зависимости от типа используемого компаратора (naturalOrder, reverseOrder ) можно получить различный результат 

boxed - собирает элементы нашего стрима в 1 тип. Не определена в стандартном типе промежуточных операций потому что эта операция только над инт стримом

## Терминальные операции

Вызов терминальной операцию в стриме завершает цепочку экземпляров Stream из промежуточных операций и возвращает результат.

- `Match` - Терминальные операции match применяются для проверки наличия совпадающего объекта в источнике стрима. В качестве аргумента используется предикат. Match запускает внутреннюю итерацию стрима и применяет параметр предиката к каждому элементу:
  - Метод anyMatch возвращает true, если предикат возвращает true для любого из элементов
  - Метод allMatch возвращает true, если предикат возвращает true для всех элементов
  - Метод noneMath возвращает true, если предикат возвращает false для всех элементов
  - Пример: выведем в консоль проверку элементов листа на наличие элемента, начинающего на «о»
```java
List<String> list = Arrays.asList("one", "two", "three");
boolean anyMatch = list.stream()
    .anyMatch(value -> value.startsWith("o"));
System.out.println(anyMatch);
```
- `CollectМетод` collect — терминальная операция, которая запускает внутреннюю итерацию элементов и собирает элементы стрима в коллекцию
  - Пример: преобразуем элементы листа и занесём их в отдельный лист
```java
List<String> list = Arrays.asList("Moscow", "NY", "Tokyo", "Moscow");
list = list.stream()
    .map(String::toUpperCase)
    .collect(Collectors.toList());
System.out.println(list); 
```
- `Count` - Метод count — терминальная операция, которая запускает внутреннюю итерацию элементов и определяет количество элементов
  - Пример: определим количество слов в четверостишии
```java
List<String> list = new ArrayList<>();
list.add("И долго буду тем любезен я народу");
list.add("Что чувства добрые я лирой пробуждал");
list.add("Что в мой жестокий век восславил я Свободу");
list.add("И милость к падшим призывал");

long count = list.stream()
    .flatMap(value -> Arrays.stream(value.split(" ")))
    .count();
System.out.println(count); 
```
- `Find` - Метод find — терминальная операция, которая производит поиск элементов в стриме
  - Метод findAny может найти один элемент из стрима. Найденный элемент может быть из любой точки стрима
  - Метод findFirst вернёт первый элемент, если таковой существует
  - Обратите внимание, что методы find возвращают тип Optional. Если стрим будет пустой, то метод не вернёт никакого результата. С помощью метода `ifPresent` проверим, был ли найден результат в Optional
  - Пример: выведем в консоль первый элемент листа строчек. Проверим, существует ли результат
```java
List<String> strings = Arrays.asList("Java Script", "Java 8", "Java 11", "Android", "Spring");

Optional<String> result = strings.parallelStream()
    .filter(s -> s.contains("Java"))
    .findFirst();

result.ifPresentOrElse(
    System.out::println,
    () -> System.out.println("There is no Java :(")
); 
```
- `ForEach` - Метод forEach — терминальная операция, которая запускает внутреннюю итерацию элементов в стриме и применяет Consumer к каждому элементу в стриме . Сам метод forEach возвращает void
```java
Stream<String> stream = stringList.stream();
stream.forEach(System.out::print);
```
- Методы min и max — это терминальные операции, которые возвращают наименьший и наибольший элемент стрима Определение наименьшего и наибольшего элемента происходит с помощью передачи определённой имплементации компаратора в методы min и max
  - Пример: найдём наименьший элемент листа целых чисел. Обратите внимание, что метод min и max возвращает тип Optional, который может содержать или не содержать результат. Если стрим пустой, метод get пробросит исключение NoSuchElementException
```java
List<Integer> intList = Arrays.asList(1, 2, 5, 10);
Optional<Integer> min = intList.stream().min(Integer::compareTo);
if (min.isPresent()) {
    Integer minString = min.get();
    System.out.println(minString);
}
```
- `Reduce` - Метод reduce — это терминальная операция, которая может свести все элементы в стриме к одному элементу
  - Reduce возвращает тип Optional. Этот необязательный параметр содержит значение, если оно есть, возвращаемое лямбдавыражением, переданным методу reduce. Получить значение можно с помощью get
  - Пример: объединим элементы листа в одну строчку через «+»
```java
List<String> stringList = ArrayList<String>();
stringList.add("one");
stringList.add("two");
stringList.add("three");

Optional<String> reduced = stringList.stream()
    .reduce((value, combinedValue) -> combinedValue + " + " + value);  // сводим 2 значения в одно
reduced.ifPresent(System.out::println); 
```
- `toArray` - это терминальная операция, которая запускает внутреннюю итерацию элементов в стриме и возвращает массив Object, содержащий все элементы
  - Пример: преобразуем лист строчек в массив объектов
```java
List<String> stringList = ArrayList<String>();
stringList.add("one");
stringList.add("two");
stringList.add("three");

Stream<String> reduced = stringList.stream()
Object[] objects = stream.toArray();
```