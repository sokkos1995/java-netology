Java Core - фундаментальные основы языка Джава, которых достаточно для дальнейшей стажировки или работы на джуниор позиции. Java Core - часть джава, которая представляет собой Java Standart Edition и набор связанных технологий. Java Core - базовая версия языка джава, которая в основном используется для разработки настольных приложений и серверных сред, для разработки автономных приложений

# Функциональное программирование и лямбда-выражения

В мире программирования существуют разные модели
- императивное - блоки команд (инструкции), которые могут отдавать данные и эти данные могут быть использованы в следующих блоках.
- декларативное - Парадигма программирования,  в которой задаётся спецификация решения задачи, то есть описывается проблема и ожидаемый результат. 
- структурное - представление программы в виде иерархической структуры блоков, где мы друг за другом описывыем происходящее в нашей функции/программе
- логическое - Парадигма программирования, основанная на автоматическом доказательстве теорем, а также раздел дискретной математики, изучающий принципы логического вывода информации на основе заданных фактов и правил вывода
- функциональное

Императивная модель нам рассказывает о том, как это сделать, а декларативная - что нам нужно сделать.

Модель функционального программирования. Допустим, у нас есть класс с 2 методами
```java
public class MyClass {
    int param;
    String name;

    public int someMethod1(int diff) {
        return param + diff;
    }

    public int someMethod2(int diff) {
        param += diff;
        return param;
    }    
}
```
Во 2 методе есть так называемые "побочные эффекты". Побочные эффекты (side effects)
- Изменение объекта (его состояния)
- Операции ввода-вывода
- Изменение значений глобальных переменных
- Обработка исключительных ситуаций
- Изменение поведения процессора при работе с числами
- Вызов метода, который совершает любое из вышеперечисленного

Также нам нужно разобраться с понятием детерминированных функций. Функции, результат работы которых зависит только от входных параметров  и ни от чего больше: ни от времени, ни от количества вызовов, ни от чего-либо ещё. Например, сколько бы раз  вы ни спросили у Google про число Пи, его ответ не изменится. Методы с побочными эффектами часто могут быть
недетерминированы

Чистая функция
- Детерминирована
- Не обладает побочными эффектами

Чтобы отделить чистые функции от "грязных", нам необходима монада. Монада — абстракция  линейной цепочки связанных вычислений, то есть нечто такое, что объединяет несколько вычислений в определённом порядке

Также есть понятие функции высших порядков. Функции высших порядков — это функции, 
которые могут принимать в качестве аргументов другие функции и в качестве результата также возвращать функцию

Концепция функционального программирования - это нечто такое, что объединяет все вышеперечисленное - и чистые функции, и монады, и функции высших порядков, и также использует рекурсию вместо циклов.

Польза функционального программирования
- Лёгкое распараллеливание кода, так как нет side effects
- Возможность «сэкономить», когда много раз вызывается функция с теми же аргументами
- Лёгкое тестирование

Отрицательные стороны функционального подхода
- Некоторые места в программе просто нереально сделать  без побочных эффектов, так как любая программа как минимум совершает операции ввода-вывода
- Из-за «нехранимости» состояния, при вычислении функций постоянно выделяется память под вычисления, и она же собирается сборщиком мусора, когда больше не нужна

## Функциональное программирование в Java

Java — не функциональный язык программирования. Однако он даёт некоторые возможности написать код в функциональном стиле (например, с помощью final классов и immutable объектов). Также джава предлагает наличие функциональных интерфейсов и лямбда выражений для написания детерминированных функций, что тоже является задатком чтобы писать код в функциональном стиле.
```java
@FunctionalInterface
public interface MyFunction {
    int calculate(int param1, int param2);
}

MyFunction myFunction = (a, b) -> a + b;
```
Более того, Java предлагает Stream API для реализации монад. Можно выполнять большую операцию как последовательность более мелких без использования побочных эффектов и хранения промежуточных результатов
```java
public List<Integer> multiplyListWithFilter(Collection<Integer> collection) {
    return clooection.stream()
        .filter(e -> e % 2 == 0)
        .map(e -> e * 2)
        .collect(Collectors.toList());
}
```
Также для реализации функций высших порядков, джава нам тоже дает некий механизм ссылок на методы. Соответственно, мы сможем использовать функции и передавать их в другие функции либо возвращать в качестве возвращаемого значения.
```java
new HigherFunction() {
    @Override
    public Function<Integer, Integer> calculate(Function<Integer, Integer> function, Function<Integer, Integer> extraFunction) {
        return value -> extraFunction.apply(function.apply(value));
    }
};

public static void main(String[] args) {
    calculateList(Arrays.asList(1, 2, 3, 4, 5), a -> a * a);
}

public static List<Integer> calculateList(List<Integer> source, MyFunction function) {
    return source.stream()
        .map(function::calculate)
        .collect(Collectors.toList());
}
```

## Лямбда-выражения

Есть определеные требования к коду
- читаемость - важно чтобы код был простой и элегантный, чтобы глядя на  код можно было понять, что там происходит
- управляемость - возможность в минимальные сроки его поправить, изменить логику

Функциональный интерфейс. Это интерфейс, который содержит только один абстрактный метод, который необходим для реализации какого либо действия. Основное назначение — использование в лямбда выражениях и ссылках на методы. Для реализации функционального интерфейса мы должны написать обычный интерфейс с одним-единственным методом, обозначить его аннотацией `@FunctionalInterface`, после чего уже реализовывать этот метод в тех местах, где нам это понадобится
```java
@FunctionalInterface
interface MyFunctionalInterface<T> {
    boolean test(T value);
}
```
Далее этот интерфейс мы можем реализовать в анонимном классе. По сути, лямбда выражения - это и есть реализация интерфейса без необходимости создавать анонимный класс. В дальнейшем, работая с лямбда выражениями, мы можем использовать предоставленные нам возможности. 
- сохранить в ссылочную переменную
- передать в любой метод в качестве аргумента
- вызвать в любой момент
- исполнить один или несколько раз

Будем реализовывать простейший калькулятор, у которого из функций есть только сложить 2 числа
```java
public class Main {
    int param;
    String name;

    public static void main(String[] args) {
        Calc calc = new Calc();
        System.out.println(calc.sum(1, 2));
    }
}

@FunctionalInterface
interface ISum {
    int sum(int a, int b);
}

class Calc implements ISum {
    @Override
    public int sum(int a, int b) {
        return a + b;
    }
}
```
Мы можем использовать эту функцию и дальше. Но мы говорили о простоте кода и есть решение получше. Для этого нам как раз и понадобятся наши лямбда выражения. 
```java
public class Main {
    int param;
    String name;

    public static void main(String[] args) {
        ISum summer = new ISum() {
            @Override
            public int sum(int a, int b) {
                return a + b;
            }
        };

        System.out.println(summer.sum(1, 2));
    }
}

@FunctionalInterface
interface ISum {
    int sum(int a, int b);
}
```
Так мы упростили наш код, избавились от класса, который написали чтобы реализовать один-единственный метод, который нам нужен.

Теперь рассмотрим синтаксис лямбда выражений. Основу лямбда-выражения составляет лямбда-оператор, который обозначается символом `->` Этот оператор разделяет лямбда-выражение на две части:
- левая часть — параметры выражения
- правая — тело лямбда-выражения, где выполняется действие

Структура
- Имеют от 0 и более входных параметров
- Параметры указываются либо явно, либо могут быть получены из контекста: можно записать как `(a)`
- Параметры заключаются в круглые скобки и разделяются запятыми: `(a, b)` или `(int a, int b)` или `(String a, int b, float c)`
- Без параметров необходимо использовать пустые круглые скобки: `() -> 42`
- Для одного параметра без указания типа скобки можно опустить: `a -> return a*a`
- Тело может содержать от 0 и более операторов
- Если тело состоит из одного оператора, его можно не заключать в фигурные скобки, а возвращаемое значение можно указывать без ключевого слова return
```java
(int a, int b) -> { return a + b;}
()  -> System.out.println("Hello world");
(String s) -> {System.out.println(s); }
0 -> 42
() -> { return 3.14 }
```
Существует 2 типа лямбда выражений
- однострочное выражение
- блок кода. можно использовать иф, свитч, циклы и тд Если мы делаем блок кода - нам необходимо обернуть это в фигурные скобки!
```java
s -> {
    if (s.isEmpty()) {
        s = "Hello world";
    }
    System.out.println(s);
};
```
Лямбда выражения были включены в jdk 8. Одним из ключевых моментов в использовании лямбда-выражений является отложенное выполнение. Иными словами, определённое в одном месте программы лямбда-выражение можем вызвать при необходимости неопределённое количество раз в различных частях программы

Рассмотрим на конкретном примере
```java
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

public class Main {

    public static void main(String[] args) {
        List<String> cities = Arrays.asList("Manchester", "London", "Paris", "Tokio");

        // Using anonymous class
        Collections.sort(cities, new Comparator<String>() {
            @Override
            public int compare(String a, String b) {
                return b.compareTo(a);
            }
        });

        // Using lambda
        Collections.sort(cities, (a, b) -> b.compareTo(a));
    }
}
```
Как это работает. Лямбда-выражение не выполняется само по себе, а образует реализацию метода, определённого в функциональном интерфейсе.

Чтобы объявить и использовать лямбда-выражение, необходимо пройти ряд этапов:
1. определить ссылки на функциональный интерфейс: `Comparator<String> comparator;`
2. создать лямбда-выражения: `comparator = (a, b) -> b.compareTo(a);`
3. использовать лямбда-выражения в виде вызова метода интерфейса: `Collectors.sort(cities, comparator);`

Стоит обратить внимание, что параметры лямбда-выражения соответствуют параметрам единственного метода `compare()` интерфейса `Comparator`, а результат соответствует возвращаемому результату метода интерфейса:
```java
@FunctionalInterface
public interface Comparator<T> {
    int compare(T var1, T var2);
}
```
В качестве тела метода `compare()` интерфейса `Comparator` нами реализован вызов у второго параметра b типа String метода compareTo(), который сравнивает объекты a и b и возвращает int `b.compareTo(a)`

Также мы говорили о том, что мы можем вызывать одну и ту же функцию, определенную лямбда-выражением, в нескольких мстах/несколько раз.
```java
public static void main(String[] args) {
    List<String> cities = Arrays.asList("Manchester", "London", "Paris", "Tokio");

    Comparator<String> comparator1 = (a, b) -> b.compareTo(a);
    Comparator<String> comparator2 = (a, b) -> a.compareTo(b);

    sortList(cities, comparator2);
}
```

## Встроенные фукнциональные интерфейсы

В JDK 8 было добавлено несколько встроенных функциональных интерфейсов, широко применяемых в Stream API.
- Predicate<T> - проверяет соблюдение некоторого условия. Если оно соблюдается, то возвращается значение true. В качестве параметра лямбда-выражение принимает объект типа T.
- Consumer<T> - выполняет некоторое действие над объектом типа Т, при этом ничего не возвращая
- Function<T,R> - представляет функцию перехода от объекта типа T к объекту типа R. Часто используется для конвертации типов данных
- Supplier<T> - не принимает никаких аргументов, но возвращает объект типа Т
- UnaryOperator<T> - принимает в качестве параметра объект типа Т, выполняет над ними операции и возвращает результат операции в виде объекта типа Т
- BinaryOperator<T> - принимает в качестве параметра 2 объекта типа Т, выполняет над ними бинарную операцию и возвращает результат в виде объекта типа Т

Predicate
```java
public interface Predicate<T> {
    boolean test(T t);
}
```
Function
```java
public interface Function<T, R> {
    R apply(T t);
}

// Example
Function<Integer, String> convert = x -> x + " dollars";
System.out.println(convert.apply(5));  // 5 dollars
```

Consumer
```java
public interface Consumer<T> {
    void accept(T t);
}

// Example
Consumer<Integer> printer = x -> System.out.printf("%d dollars \n", x);
printer.accept(600);
```

Supplier
```java
public interface Supplier<T> {
    T get();
}

// Example
Supplier<String> stringFactory = () -> "new";
String str = stringFactory.get();
System.out.println(str);
```

UnaryOperator
```java
public interface UnaryOperator<T> {
    T apply(T t);
}

// Example
UnaryOperator<Integer> square = x -> x * x;
System.out.println(square.apply(5));  // 25
```

BinaryOperator
```java
public interface BinaryOperator<T> {
    T apply(T t1, T t2);
}

// Example
BinaryOperator<Integer> multiply = (x, y) -> x * y;
System.out.println(multiply.apply(3,5)); // 15
```

Если ни один функциональный интерфейс не подходит для решения задачи, мы можем написать свой. Зачастую, это используется при создании так называемых колбэков — объектов, которые
определяются в классе А и передаются в качестве аргумента в класс Б
```java
@FunctionalInterface
public interface OnDoneListener<T> {
    void onDone(T v);
}
```

## Ссылки на метод

В Java 8 добавилась новая функциональность, названная ссылкой на метод. Это упрощение использования лямбда выражений, которые реализуют функциональный интерфейс. Если лямбда-выражение используется для вызова метода функционального интерфейса, можно его заменить ссылкой на метод. Это компактная и простая форма лямбда-выражения. Есть несколько типов ссылок на метод (их можно применять к):
- ссылка на статический метод
- ссылка на метод экземпляра класса
- ссылка на конструктор

Можно ссылаться на статический метод класса. Синтаксис: `ContainingClass::staticMethodName`  
Создадим статический метод в классе Main и сделаем на него ссылку при реализации лямбда-выражения:
```java
public static void main(String[] args) {
    Consumer<String> sayable = Main::saySomething;
    sayable.accept("Hello, this is static method");
}

private static void saySomething(String s) {
    System.out.println(s);
}
```
В роли функционального интерфейса выступает интерфейс Consumer с одним методом без реализации `accept()`. В роли статического метода выступает метод saySomething(), который выводит в консоль строку

Можно ссылаться на метод экземпляра класса. Синтаксис: `containingObject::instanceMethodName`  
Создадим метод в классе Main и сделаем на него ссылку при реализации лямбда-выражения: 
```java
public class Main {

    public static void main(String[] args) {
        Main main = new Main();
        Consumer<String> sayable = main::saySomething;
        sayable.accept("Hello, this is non-static method");
    }

    private void saySomething(String message) {
        System.out.println(message);
    }
}
```
В роли функционального интерфейса выступает интерфейс Consumer с одним методом без реализации `accept()`. В роли метода выступает метод экземпляра класса saySomething(), который выводит в консоль строку

Можно ссылаться на конструктор класса. Синтаксис `ClassName::new`  
Определим функциональный интерфейс Consumer и класс Main с конструктором: 
```java
public Main(String string) {
    System.out.println(string);
}

public static void main(String[] args) {
    Consumer<String> sayable = Main::saySomething;
    sayable.accept("Hello, this is static method");
}
```
В роли функционального интерфейса выступает интерфейс Consume с одним методом без реализации `accept()`. В качестве класса выступает Main, в конструктор которого передаётся строка и выводится в консоль