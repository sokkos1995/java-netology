# Структура класса

Основы ООП, классы как шаблоны для объектов, как мы можем проектировать память для наших объектов.

## Поля класса

Создадим новый джава класс. Мы можем использовать этот класс для того чтобы создать новый тип данных в джаве. Опишем в нем то, что мы хотим чтобы каждый объект знал о себе
```java
public class Singer {
    public String name;  // не public!
    public int age;
    public int rating;
}
```
Этого достаточно чтобы каждый раз когда джава будет создавать новый объект - она будет внутри него создавать 3 ячейки: имя, возраст и рейтинг. Теперь при создании экземпляра класса мы сможем задать ему данные атрибуты
```java
public class Lecture06 {    
    public static void main(String[] args) {
        Singer singer = new Singer();
        singer.name = "Petya";
        singer.age = 27;
        singer.rating = 10;
    }
}
```
В итоге вся информация у нас упаковалась внутрь ячеек, которые находятся внутри объекта, и уже адрес на этот объект мы сохранили в переменной singer. Теперь чтобы передать информацию о певце куда то, нам достаточно будет передать ячейку типа Singer. Ячейки имя, возраст и рейтинг будут называться полями. Рассмотрим отличия этих полей от статических полей, для этого создадим класс со статическим полей
```java
public class A {
    public static int x;
}
```
Для того чтобы обратиться к статическому полю, достаточно указать название класса, точку и название поля и присвоить туда что то. Обратите внимание, что при обращении к нестатическому полю ия класса не указывается! Мы указываем переменную, внутри которой находится адрес объекта, у которого есть эта переменная, именно это поле. 
```java
public class Lecture06 {    
    public static void main(String[] args) {
        Singer singer = new Singer();
        singer.name = "Petya";
        singer.age = 27;
        singer.rating = 10;

        A.x = 5;
    }
}
```
Отличие философское - когда мы объявляем статическое поле, у нас создается одна ячейка на программу и к ней мы обращаемя через имя класса, указывая джаве, где ее искать. У нас одна ячейа с именем х, находящаяся в классе А. Когда же я объявляю переменную name в классе Singer без иджентификатора static, это означает, что эта переменная будет жить внутри каждого объекта данного типа данных. До того как мы создадим первого певца у нас не будет ни одной переменной типа name (точнее, поля). Поэтому бессмысленно было бы обращаться к этому полю через имя класси (писать `Singer.name = "Petya";`), ведь джаве будет непонятно, к какой ячейке с именем name мы обращаемся, потому что у каждого объекта типа Singer она будет своей. Джава от нас потребует указать конкретный объект, с которым мы имеем дело. В итоге мы видим большую разницу между статическими и не статическими полями. Статические - аналог глобальных переменных, не-статические - аналог внутренних переменных внутри каждого объекта этого типа данных.  
С помощью нестатических полей мы можем проектировать память объекта, а именно какие данные они должны хранить у себя внутри.

## Методы класса

Мы пока что не спроектировали никакие действия нашего певца. Для этого мы создаем метод в классе. Обратите внимание на то, что здесь не используется слово `static`, поскольку метод не является статическим. Пишем `public {возвращаемый тип} {имя метода} ({Параметры})`
```java
public class Singer {
    public String name;
    public int age;
    public int rating;

    public void sing(String verse) {
        System.out.println("Я, " + name + ", пою тебе: " + verse);
    }
}
```
Обратите внимание, что мы обращаемся к статическим полям без точки! `System.out.println("Я, " + name + ", ` , а не `Singer.name`, без указания объекта, с которым имеем дело. Мы можем не указывать объект, поскольку мы указали этот объект при вызове команды. Здесь будут вызываться не-статические поля именно того объекта, на котором мы вызвали команду.

При этом мы вызываем этот метод указывая объект этого певца! Это не является статическим методом, поэтому мы не указываем класс, в котором он обозначен. В случае статических методов было бы достаточно указать джаве класс где искать этот метод. Здесь же мы указываем просто название переменной, где хранится адрес этого объекта
```java
public class Main {
    public static void main(String[] args) {
        Singer singer = new Singer();
        singer.name = "Petya";
        singer.age = 8;
        singer.rating = 3;
        singer.sing("Good morning!");
        System.out.println(singer);
    }
}
```

Создадим еще какую нибудь команду для певца.
```java
public class Singer {
    public String name;
    public int age;
    public int rating;

    public void sing(String verse) {
        System.out.println("Я, " + name + ", пою тебе: " + verse);
    }

    public boolean isTooYoung() {
        if (age < 10) {
            return true;
        } else {
            return false;
        }
    }

    public String toString() {
        return "[" + rating + "] " + name + " (" + age + " лет)";
    }
}
```
Разберем еще одну полезную команду - `toString()`. Дело в том что когда мы просим вывести какой то объект на экран, то выведется следующее:
```java
System.out.println(singer);
// Singer@2a3046da
```
Как джава решает, в каком виде вывести объект на экран? На самом деле джава не хочет разбираться, что там происходит внутри объекта, как он устроен. Джава просто вызывает встроенную команду `toString()`, эта команда ничего не принимает параметрами, но возвращает текст в ответ, именно он и выводится на экран
```java
public String toString() {
    return "[" + rating + "] " + name + " (" + age + " лет)";
}
// [3] Petya (8 лет)
```
Мы можем создавать мноого объектов этого типа, например, создать еще одного певца
```java
public class Main {
    public static void main(String[] args) {
        Singer singer = new Singer();
        singer.name = "Petya";
        singer.age = 8;
        singer.rating = 3;
        singer.sing("Good morning!");
        System.out.println(singer);

        Singer singer2 = new Singer();
        singer2.name = "Anya";
        singer2.age = 15;
        singer2.rating = 4;
        System.out.println(singer2);
    }
}
```
Имена певцов - различные ячейки и будут находиться в разных объектах! Именно поэтому при обращении к нестатическому полю мы вынуждены указывать имеено объект, с которым имеем дело. Так же как и при вызове нестатического метода мы вынуждены указать объект, у которого мы его вызываем. Потому что по определениюнестатический метод - это та команда, которую должен выполнять объект, потому что он использует собственные данные.

## Констрак

Как нам провильно инициализировать объекты, то есть готовить их изначальное правильно и корректное состояние.