# Типы данных в Java: примитивы

Как мы можем хранить
- целые числа
- дробные числа
- символы и логические значения

## Знакомство с InteliJ Idea

Ставим 16 джаву оракловской JDK.

Базовая структура проекта
- `src` - для джава файлов, в которых мы пишем код. Расширение `.java` отображаться не будет
- `netology.iml` - файл для управления нашим проектом

Шорткаты
- `psvm` - `public static void main(String[] args) {}`
- `sout` - `System.out.println();`

Режим отладки:
- `step over` - перешагнуть - мы выполним целиком ту строку, на которой находимся
- `step into` - зашагнуть внутрь - если бы был вызов какой то команды, то мы зашли бы внутрь и начали шагать по ней внутри 

В идее удобно создавать пакеты! + они удобно импортятся

## Целочисленные типы данных

В джаве существует 4 типа данных чтобы хранить в них целые числа
- byte - 8 битов, от -128 до 127
- short - 16
- int - 32
- long - 64  
Джава по умолчанию считает что число интовое, если мы хотим тип лонг, то нам в конце нужно написать букву `L` - так мы говорим джаве что знаем что это число лонгового типа
```java
public class Lecture04 {
    public static void main(String[] args) {
        byte b = 3;
        short s = 15;
        int x = 10;
        long q = 10_000_000_000L;
        System.out.println(q);
    }
}
```
Для приведения типов можем указать желаемый тип `int i = (int) x;`, при этом если число слишком большое - ошибки не вылезет
```java
public class Lecture04 {
    public static void main(String[] args) {
        long q = 10_000_000_000L;
        int x = (int) q;
        System.out.println(x);
        // 1410065408
    }
}
```
Попробуем поувеличивать число в цикле. Джава не предупредит нас, что мы выходим за границы значений! и будут сыпаться неправильные значения. Так сделано потому что примитивные типы данных сделаны для того чтобы работать быстро. Джава считает как умеет 
```java
public class Lecture04 {
    public static void main(String[] args) throws Exception{
        int x = 1;

        while (true) {
            System.out.println(x);
            x *= 10;
            Thread.sleep(300);
        }        
    }
}
// 1
// 10
// 100
// 1000
// 10000
// 100000
// 1000000
// 10000000
// 100000000
// 1000000000
// 1410065408
// 1215752192
// -727379968
// 1316134912
// 276447232
// -1530494976
```
Над целыми числами можно делать обычные операции - умножение, сложение и тд. При этом если складывать разные типы, то результирующим типом должен быть самый жирный тип. Если складывать инт и лонг, то и результирующий тип должен быть лонг
```java
public class Lecture04 {
    public static void main(String[] args) throws Exception{
        int x = 1;
        long xx = 100;

        int y = x + xx;  // ругнется! нужно `long y = x + xx; `
    }
}
```
Складывание небольших типов - идет по умолчаниюб в инт, если мы уверены что получится байт/шорт - нужно указать напрямую
```java
public class Lecture04 {
    public static void main(String[] args) throws Exception{
        byte x = 1;
        byte xx = 100;

        byte y = (byte)(x + xx);
        System.out.println(y);
    }
}
```

## Вещественные типы данных

У Java есть особенности в запоминании дробных чисел. Это связано с тем, как хранятся дробные числа.
```java
public class Lecture04 {
    public static void main(String[] args) throws Exception{
        double d1 = 0.3 + 0.3 + 0.3;
        double d2 = 0.9;

        System.out.println(d1 == d2);  // false
        System.out.println(d1);  // 0.8999999999999999
        System.out.println(d2);  // 0.9
    }
}
```
С хранением дробных чисел используется такой подход: запоминается 2 целых числа - количество порядков в целом числе и какое то число без точки (энное количество знаков). Например:
```bash
346529834534.27546430872520
12 346529834534275464308725  # не до конца!
# преобразуем эти 2 целых числа в 0 и 1
010100001011110010....01010
# так как мы умеем преобразовывать двоичную в десятиричную и наоборот - восстановим число
12 346529834534275464308725
# теперь поставим точку после 12 цифры
346529834534.275464308725
# это не будет равно исходному числу! какое то количество знаков пропадет
```
Мы запоминаем с какой то погрешностью, зато придумали алгоритм. Тут 0.3 запоминается в виде бесконечной дроби, так что запоминается только первые n знаков.

Способы для сравнения дробных чисел:
```java
public class Lecture04 {
    public static void main(String[] args) throws Exception{
        double d1 = 0.3 + 0.3 + 0.3;
        double d2 = 0.9;

        // можно посмотреть, насколько числа отстоят друг от друга
        if (Math.abs(d1 - d2) < 0.00001) {
            // Math.abs - для высчитывания модуля
            System.out.println();
        }
    }
}
```
Еще одна проблема с дробными числами - с ними получится поделить на 0 (инты бы упали с ошибкой, дробный тип - джава считает что это очень маленькое число, просто были отброшены последние цифры)
```java
public class Lecture04 {
    public static void main(String[] args) throws Exception{
        double x = 5;
        double y = 0;

        System.out.println(x / y);  // Infinity

        double d1 = 5 / y;
        double d2 = 4 / y;        
        System.out.println(d1);  // Infinity
        System.out.println(d1 - d2);  // NaN        
    }
}
```
Помимо double (64 бита) есть float (32 бита). Дабл - тип по умолчанию. Если хотим использовать флоат - нужно в конце добавить большую букву F
```java
public class Lecture04 {
    public static void main(String[] args) throws Exception{
        float x = 3.5F;
        double y = 0.5;
    }
}
```

## Символьный и логический типы данных

Примитивный тип данных char используется для хранения символов, bool - логический тип.  
Для типа char необходимо использовать одинарные кавычки - так джава поймет, что мы сохраняем 1 символ, а не текст из 1 символа. Также можно сохранять сивол по его номеру (например 33 - сохранить символ под номером 33 в таблице кодировок, это `!`)
```java
public class Lecture04 {
    public static void main(String[] args) throws Exception{
        char x = 'D';
        char y = 33;

        System.out.println(y);  // !
    }
}
```
Символьные типы в основном используются чтобы анализировать текст посимвольно.

Использование булевых типов:
```java
public class Lecture04 {
    public static void main(String[] args) throws Exception{
        boolean b = true;
        boolean b1 = 5 > 3;

        System.out.println(b); 
        System.out.println(b1); 

        char c = 33;
        boolean b2 = 33 == '!';

        if (b2) {
            System.out.println("Yes");
        }
    }
}
```