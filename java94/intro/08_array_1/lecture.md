# Массивы одномерные

Масиивы - специальные инструменты в джаве, которые позволяют создавать целые наборы данных. Обычно это шаблонные данные, которые мы обрабатываем через циклы.

## Основы работы с массивами

Мы можем создавать целые наборы ячеек, указывать им размер, обращаться к конкретным ячейкам по их номеру. Например, целое число мы сохраним в переменную с помощью строки `int x;`, а для массива целых чисел - `int[] arr_x = new int[5];` , где 5 - размер массива. Так джава нам создаст набор из 5 интовых ячеек и адрес этого набора положит в переменную arr_x. Для обращения к элементам массива используем `arr_x[0]`. Изначально все ячейки заполнены нулями (это значение по умолчанию). Важной особенностью массивов является то, что мы не можем менять его размер! Он указывается в момент создания (ни добавлять, ни удалять ячейки).  
Обычный вывод массива на экран работает плохо
```java
public class Main {
    public static void main(String[] args) {
        int x;
        int[] arr_x = new int[5];
        System.out.println(arr_x);
        // то же самое что и
        System.out.println(arr_x.toString());
        // [I@7fbe847c

        System.out.println(Arrays.toString(arr_x));
        // [0, 0, 0, 0, 0]        
    }
}
```
У массивов toString работает плохо, поэтому для массивов мы должны воспользоваться вспомогательным методом. У нас есть целый класс с набором статических методов, который прекрасно работает с массивами. Так что используем `Arrays.toString(arr_x)`.

Создадим массив и заполним его данными. Если мы предварительно знаем все значения массива - можем создать его с помощью такой вот нотации `int[] arr_x = {5, 1, 3, 4, 2};`. Джава уже знает, что нам нужен интовый массив, поэтому джава сама сосчитает количество элементов, которые мы перечислили, создаст массив такого размера, а дальше поочередно присвоит элементам массива эти значения.

Попробуем сравнить 2 массива `System.out.println(arr_1 == arr_2);`. С точки зрения джавы это непосредственное сравнение значений, которые хранятся в этих переменных. Это переменные ссылочного типа данных и там хрянятся адреса, соответственно, джава будет просто сравнивать адреса. У нас есть 2 одинаковых массива, но это 2 массива-близнеца и живут они по разным адресам, так что такое сравнение выдаст false. НО! `arr1.equals(arr2)` тоже выдаст false, он для массивов работает как ==. Правильно будет сравнить через `Arrays.equals(arr1, arr2);`
```java
import java.util.Arrays;

public class Main {
    public static void main(String[] args) {
        int[] arr1 = {5, 1, 3};
        int[] arr2 = new int[3];
        arr2[0] = 5;
        arr2[1] = 1;
        arr2[2] = 3;

        System.out.println(arr1 == arr2);  // false
        System.out.println(arr1.equals(arr2));  // false
        System.out.println(Arrays.equals(arr1, arr2));  // true
    }
}
```
Мы можем в качестве массива использовать и любой другой тип. Даже те, которые создавали сами - например, `Singer[] arr_singer = new Singer[3];`. Обращу внимание на то, что мы должны указать число в квадратных скобках, но можем указать и интовую переменную, и метод, который вернет нам число. Главное чтобы джава четкознала в момент исполнения, какое число ей надо использовать. В момент компиляции это число может быть неизвестно.
```java
public class Main {
    public static void main(String[] args) {
        Singer[] singers = {
            new Singer("Петя", 10),
            new Singer("Ваня", 12, 5),
            new Singer("Саша", 9),
            new Singer("Коля", 14),
        };
        System.out.println(Arrays.toString(singers));
    }
}
```

## Работа с массивами в цикле. Цикл foreach

Как массивы позволяют нам шаблонно обрабатывать целые блоки данных. Создадим массив с именами. Допустим, перед нами стоит задача вывести все имена, которые не начинаются на букву П. Для этого 
```java
public class Main {
    public static void main(String[] args) {
        String[] names = {"Петя", "Вася", "Маша", "Даша", "Катя"};

        for (int i = 0; i < names.length; i++) {
            if (!names[i].startsWith("П")) {
                System.out.println(names[i]);
            }
        }
    }
}
```
- names.length - смотрим длину массива
- !names[i].startsWith("П") - тут ! - это отрицание

Массивы именно поэтому имеют однотипное значение, поскольку назначение массивов - именно однотипная обработка!

Для обработки наборов (массив - это не единственный вид наборов), в джаве есть специальный цикл foreach.
```java
for (...; ...; ...) {}  // 3 секции

for (String name: names) {}  // 2 секции, справа - набор, по которому хотим пройтись, слева - заводим переменную, тип которой совпадает с типом элемента набора
```
```java
public class Main {
    public static void main(String[] args) {
        String[] names = {"Петя", "Вася", "Маша", "Даша", "Катя"};

        for (int i = 0; i < names.length; i++) {
            if (!names[i].startsWith("П")) {
                System.out.println(names[i]);
            }
        }

        for (String name: names) {
            if (!name.startsWith("П")) {
                System.out.println(name);
            }            
        }
    }
}
```
Из практики - первый способ (for i) используется когда мы хотим вывести какую то дополнительную информацию, например, номер итерации. В остальных случаях используем foreach.

Какие еще полезные методы есть в классе Arrays. 
- сортировка `Arrays.sort(arr);`
- копирование массива `Arrays.clone(arr)` (иначе при присваивании у нас будет присвоен адрес объекта, то есть у 2 переменных будет 1 адрес, при изменении одной из них - вторая изменится тоже)
- copyOf() — копирует массив
- copyOfRange() — копирует часть массива
- toString() — возвращает все элементы в виде одной строки
- binarySearch() — ищет элемент методом бинарного поиска
- fill() — заполняет массив переданным значением
- equals() — проверяет на идентичность массивы
- asList() — возвращает массив как коллекцию

## Практическое задание. Расчет средней температуры

Необходимо найти среднемесячную температуру, опираясь на данные, введенные пользователем в качестве пары день-температура.

```java
import java.util.Arrays;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // массив размером в количество дней
        int[] temps = new int[30];
        boolean[] isFilled = new boolean[30];
        while (true) {
            System.out.println("Введи два числа: дата температура");
            String input = scanner.nextLine(); // "11 31"
            if ("end".equals(input)) {
                break;
            }

            String[] parts = input.split(" "); // результат сплита - массив из стрингов ["11", "31"]
            int day = Integer.parseInt(parts[0]) - 1;  // нумерация ячеек массива начинается с 0!
            int t = Integer.parseInt(parts[1]);
            temps[day] = t;
            isFilled[day] = true;

            double sum = 0;
            for (int tt : temps) {
                sum += tt;
            }
            int cnt = 0;
            for (boolean f : isFilled) {
                if (f) {
                    cnt++;
                }
            }
            System.out.println("Средняя температура: " + (sum / cnt));
        }
    }
}
```